["\nTest Your Solution:\n```python\nfrom utils.hog import algorithm\nfrom utils.tests import raises\n\n\n@raises(NameError)\ndef test_name():\n    \"\"\"Is the name correct?\"\"\"\n    algorithm(torch.randn(1, 1))\n\n\ndef test_shape():\n    \"\"\"Does the shape match?\"\"\"\n    assert algorithm(torch.randn(1, 1)).shape == (1, 1)\n\n\ndef test_values():\n    \"\"\"Do the values match?\"\"\"\n    M = torch.randn(3, 3)\n    L = algorithm(M)\n    for i in range(3):\n        for j in range(3):\n            if i <= j:\n                assert L[i, j] == M[i, j]\n            else:\n                assert L[i, j] == 0\n```\n\"\"\"\n\n\ndef algorithm(M: torch.Tensor) -> torch.Tensor:\n    \"\"\"\n    args:\n        M: torch.Tensor of shape (N, N)\n\n    return:\n        L: torch.Tensor of shape (N, N), which is the lower triangular part of M\n    \"\"\"\n    N = M.size(0)\n    L = torch.tensor([[M[i, j] if i <= j else 0 for j in range(N)] for i in range(N)])\n    return L\n", "\nTest your corrected solution with the provided test cases.\n\nTest Case 1:\n\nInput:\n```python\nM = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n```\n\nOutput:\n```python\ntensor([[1, 0, 0],\n        [4, 5, 0],\n        [7, 8, 9]])\n```\n\nTest Case 2:\n\nInput:\n```python\nM = torch.tensor([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]])\n```\n\nOutput:\n```python\ntensor([[ 1,  0,  0,  0],\n        [ 5,  6,  0,  0],\n        [ 9, 10, 11,  0],\n        [13, 14, 15, 16]])\n```\n\nTest Case 3:\n\nInput:\n```python\nM = torch.tensor([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]])\n```\n\nOutput:\n```python\ntensor([[ 1,  0,  0,  0,  0],\n        [ 6,  7,  0,  0,  0],\n        [11, 12, 13,  0,  0],\n        [16, 17, 18, 19, 20],\n        [21, 22, 23, 24, 25]])\n```\n\nTest Case 4:\n\nInput:\n```python\nM = torch.tensor([[1, 2, 3, 4, 5, 6], [7, 8, 9, 10, 11, 12], [13, 14, 15, 16, 17, 18], [19, 20, 21, 22, 23, 24], [25, 26, 27, 28, 29, 30], [31, 32, 33, 34, 35, 36]])\n```\n\nOutput:\n```python\ntensor([[ 1,  0,  0,  0,  0,  0],\n        [ 7,  8,  0,  0,  0,  0],\n        [13, 14, 15,  0,  0,  0],\n        [19, 20, 21, 22, 23,  0],\n        [25, 26, 27, 28, 29, 30],\n        [31, 32, 33, 34, 35, 36]])\n```\n\nTest Case 5:\n\nInput:\n```python\nM = torch.tensor([[1, 2, 3, 4, 5, 6, 7], [8, 9, 10, 11, 12, 13, 14], [15, 16, 17, 18, 19, 20, 21], [22, 23, 24, 25, 26, 27, 28], [29, 30, 31, 32, 33, 34, 35], [36, 37, 38, 39, 40, 41, 42], [43, 44, 45, 46, 47, 48,", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\nimport functools\n\n\ndef run(function_to_test, get_args, test_cases, name):\n    failed_test_cases = []\n\n    for index, (args, expected) in enumerate(test_cases):\n        try:\n            result = function_to_test(*args)\n            assert result.allclose(expected), (\n                f\"{name} test {index + 1} failed:\\nExpected\\n{expected}\\nGot\\n{result}\"\n            )\n        except AssertionError as e:\n            failed_test_cases.append(\n                f\"{name} test {index + 1} failed with input {args}:\\n{e}\"\n            )\n\n    if failed_test_cases:\n        msg = \"\\n\\n\".join(failed_test_cases)\n        raise AssertionError(f\"{len(failed_test_cases)} {name} tests failed:\\n{msg}\")\n\n\nclass TestAlgorithm(unittest.TestCase):\n    def test_algorithm(self):\n        def get_args(n):\n            return (torch.randint(-10, 10, (n, n)),)\n\n        run(\n            algorithm,\n            get_args,\n            [\n                (\n                    (3, 3),\n                    torch.tensor([[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [2.0, 3.0, 0.0]]),\n                ),\n                (\n                    (2, 2),\n                    torch.tensor([[0.0, 0.0], [1.0, 0.0]]),\n                ),\n                (\n                    (1, 1),\n                    torch.tensor([[0.0]]),\n                ),\n            ],\n            \"algorithm\",\n        )\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n", "\nTest Your Solution:\nYou can test your solution like this:\n```python\nfrom helpers.python_test import test\n\n@pytest.mark.parametrize(\"M,expected\", [\n    (torch.rand(3, 3), torch.tril(torch.rand(3, 3))),\n    (torch.rand(4, 4), torch.tril(torch.rand(4, 4))),\n    (torch.rand(5, 5), torch.tril(torch.rand(5, 5))),\n])\ndef test_algorithm(M: torch.Tensor, expected: torch.Tensor):\n    result = algorithm(M)\n    assert torch.allclose(result, expected)\n```\n'''\n\n# Solution\nimport torch\n\ndef algorithm(M: torch.Tensor) -> torch.Tensor:\n    '''\n    args:\n        M: torch.Tensor of shape (N, N)\n\n    return:\n        L: torch.Tensor of shape (N, N), which is the lower triangular part of M\n    '''\n    N = M.size(0)\n    L = torch.tensor([[M[i, j] if i <= j else 0 for j in range(N)] for i in range(N)])  \n    return L\n\n# Test your solution\nfrom helpers.python_test import test\n\n@pytest.mark.parametrize(\"M,expected\", [\n    (torch.rand(3, 3), torch.tril(torch.rand(3, 3))),\n    (torch.rand(4, 4), torch.tril(torch.rand(4, 4))),\n    (torch.rand(5, 5), torch.tril(torch.rand(5, 5))),\n])\ndef test_algorithm(M: torch.Tensor, expected: torch.Tensor):\n    result = algorithm(M)\n    assert torch.allclose(result, expected)\n", "\nTest Your Solution:\nYou can test your solution like this:\n```python\nfrom helpers.python_test import test\n\n@pytest.mark.parametrize(\"M,expected\", [\n    (torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]]), torch.tensor([[1, 0, 0], [4, 5, 0], [7, 8, 9]])),\n    (torch.tensor([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]), torch.tensor([[1, 0, 0, 0], [5, 6, 0, 0], [9, 10, 11, 0], [13, 14, 15, 16]])),\n    (torch.tensor([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]]), torch.tensor([[1, 0, 0, 0, 0], [6, 7, 0, 0, 0], [11, 12, 13, 0, 0], [16, 17, 18, 19, 0], [21, 22, 23, 24, 25]])),\n])\ndef test_algorithm(M, expected):\n    result = algorithm(M)\n    assert torch.all(torch.eq(result, expected))\n```\n\"\"\"\n\nimport torch\n\ndef algorithm(M: torch.Tensor) -> torch.Tensor:\n    '''\n    args:\n        M: torch.Tensor of shape (N, N)\n\n    return:\n        L: torch.Tensor of shape (N, N), which is the lower triangular part of M\n    '''\n    N = M.size(0)\n    L = torch.tensor([[M[i, j] if i <= j else 0 for j in range(N)] for i in range(N)])  \n    return L\n\n\nif __name__ == '__main__':\n    from helpers.python_test import test\n    from helpers.torch_test import test_tensor\n\n    @test\n    def solution_works():\n        M = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n        L = algorithm(M)\n        test_tensor(L, torch.tensor([[1, 0, 0], [4, 5, 0], [7, 8, 9]]))\n\n    solution_works()\n\n    @test\n    def solution_works_2():\n        M = torch.tensor([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]])\n        L = algorithm(M)\n        test_tensor(L, torch.tensor([[1, 0, 0, 0], [5, 6, 0, 0], [9, 10, 11, 0], [13, 14, 15, 16]]))\n\n    solution_works_2()\n\n    @test\n    def solution_works_3():\n        M = torch.tensor([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 1", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Udacity\n# Author: Alexis M. Thornton\n\nimport torch\n\ndef algorithm(M: torch.Tensor) -> torch.Tensor:\n    '''\n    args:\n        M: torch.Tensor of shape (N, N)\n\n    return:\n        L: torch.Tensor of shape (N, N), which is the lower triangular part of M\n    '''\n    N = M.size(0)\n    L = torch.tensor([[M[i, j] if i <= j else 0 for j in range(N)] for i in range(N)])  \n    return L\n\n\n# Test Cases\n\ntest1 = torch.randint(0, 10, size=(5, 5))\nexpected_output1 = algorithm(test1)\nprint(expected_output1)\n\ntest2 = torch.randint(0, 10, size=(10, 10))\nexpected_output2 = algorithm(test2)\nprint(expected_output2)\n\ntest3 = torch.randint(0, 10, size=(15, 15))\nexpected_output3 = algorithm(test3)\nprint(expected_output3)\n\n", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\nimport functools\n\n\nclass TestSolution(unittest.TestCase):\n    def test(self):\n        torch.manual_seed(1)\n        M = torch.randint(-10, 10, (5, 5))\n        self.assertEqual(functools.reduce(lambda x, y: x * y, algorithm(M).shape),\n                         functools.reduce(lambda x, y: x * y, M.shape))\n        self.assertEqual(algorithm(M), torch.tril(M))\n\n\nif __name__ == '__main__':\n    unittest.main()\n", "\nTest your corrected solution with the provided test cases.\n\nTest Case 1:\n\nInput:\n```python\nM = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n```\n\nOutput:\n```python\ntensor([[1, 0, 0],\n        [4, 5, 0],\n        [7, 8, 9]])\n```\n\nTest Case 2:\n\nInput:\n```python\nM = torch.tensor([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]])\n```\n\nOutput:\n```python\ntensor([[ 1,  0,  0,  0],\n        [ 5,  6,  0,  0],\n        [ 9, 10, 11,  0],\n        [13, 14, 15, 16]])\n```\n\nTest Case 3:\n\nInput:\n```python\nM = torch.tensor([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]])\n```\n\nOutput:\n```python\ntensor([[ 1,  0,  0,  0,  0],\n        [ 6,  7,  0,  0,  0],\n        [11, 12, 13,  0,  0],\n        [16, 17, 18, 19, 20],\n        [21, 22, 23, 24, 25]])\n```\n\nTest Case 4:\n\nInput:\n```python\nM = torch.tensor([[1, 2, 3, 4, 5, 6], [7, 8, 9, 10, 11, 12], [13, 14, 15, 16, 17, 18], [19, 20, 21, 22, 23, 24], [25, 26, 27, 28, 29, 30], [31, 32, 33, 34, 35, 36]])\n```\n\nOutput:\n```python\ntensor([[ 1,  0,  0,  0,  0,  0],\n        [ 7,  8,  0,  0,  0,  0],\n        [13, 14, 15,  0,  0,  0],\n        [19, 20, 21, 22, 23,  0],\n        [25, 26, 27, 28, 29, 30],\n        [31, 32, 33, 34, 35, 36]])\n```\n\nTest Case 5:\n\nInput:\n```python\nM = torch.tensor([[1, 2, 3, 4, 5, 6, 7], [8, 9, 10, 11, 12, 13, 14], [15, 16, 17, 18, 19, 20, 21], [22, 23, 24, 25, 26, 27, 28], [29, 30, 31, 32, 33, 34, 35], [36, 37, 38, 39, 40, 41, 42], [43, 44, 45, 46, 47, 48,", "\nTest Your Solution:\nYou can test your solution like this:\n```python\nfrom helpers.python_test import test\n\n@test\ndef solution_works():\n    M = torch.randint(0, 10, (5, 5))\n    L = algorithm(M)\n    assert L.shape == (5, 5)\n    assert L.sum() == M.tril().sum()\n    assert L.tril() == M.tril()\n```\n'''\n\n# Solution\nimport torch\n\ndef algorithm(M: torch.Tensor) -> torch.Tensor:\n    '''\n    args:\n        M: torch.Tensor of shape (N, N)\n\n    return:\n        L: torch.Tensor of shape (N, N), which is the lower triangular part of M\n    '''\n    N = M.size(0)\n    L = torch.tensor([[M[i, j] if i <= j else 0 for j in range(N)] for i in range(N)])  \n    return L\n\n# Test your solution\nfrom helpers.python_test import test\n\n@test\ndef solution_works():\n    M = torch.randint(0, 10, (5, 5))\n    L = algorithm(M)\n    assert L.shape == (5, 5)\n    assert L.sum() == M.tril().sum()\n    assert L.tril() == M.tril()", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\nimport random\n\n\nclass TestSolution(unittest.TestCase):\n    def test_shape(self):\n        for _ in range(20):\n            N = random.randint(1, 100)\n            M = torch.rand(N, N)\n            L = algorithm(M)\n            self.assertEqual(L.shape, M.shape)\n\n    def test_values(self):\n        for _ in range(20):\n            N = random.randint(1, 100)\n            M = torch.rand(N, N)\n            L = algorithm(M)\n            for i in range(N):\n                for j in range(N):\n                    if i <= j:\n                        self.assertEqual(L[i, j], M[i, j])\n                    else:\n                        self.assertEqual(L[i, j], 0)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\nimport functools\n\n\nclass TestSolution(unittest.TestCase):\n    def test(self):\n        torch.manual_seed(1)\n        M = torch.randint(0, 10, (5, 5))\n        self.assertEqual(functools.reduce(torch.add, algorithm(M)), M)\n\n\nif __name__ == '__main__':\n    unittest.main()\n", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\nimport random\n\n\nclass TestSolution(unittest.TestCase):\n    def test_shape(self):\n        for _ in range(20):\n            N = random.randint(1, 100)\n            M = torch.rand(N, N)\n            L = algorithm(M)\n            self.assertEqual(L.shape, M.shape)\n\n    def test_values(self):\n        for _ in range(20):\n            N = random.randint(1, 100)\n            M = torch.rand(N, N)\n            L = algorithm(M)\n            for i in range(N):\n                for j in range(N):\n                    if i <= j:\n                        self.assertEqual(L[i, j], M[i, j])\n                    else:\n                        self.assertEqual(L[i, j], 0)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n", "\nTest Your Solution:\nYou can test your solution like this:\n```python\nfrom helpers.python_test import test\n\n@test\ndef solution_works():\n    M = torch.randint(0, 10, (5, 5))\n    L = algorithm(M)\n    assert L.shape == (5, 5)\n    assert L.sum() == M.tril().sum()\n    assert L.trace() == M.trace()\n    assert (L == M.tril()).all()\n```\n'''\n\n# Solution\nimport torch\n\ndef algorithm(M: torch.Tensor) -> torch.Tensor:\n    '''\n    args:\n        M: torch.Tensor of shape (N, N)\n\n    return:\n        L: torch.Tensor of shape (N, N), which is the lower triangular part of M\n    '''\n    N = M.size(0)\n    L = torch.tensor([[M[i, j] if i <= j else 0 for j in range(N)] for i in range(N)])  \n    return L\n\n# Test your solution\nfrom helpers.python_test import test\n\n@test\ndef solution_works():\n    M = torch.randint(0, 10, (5, 5))\n    L = algorithm(M)\n    assert L.shape == (5, 5)\n    assert L.sum() == M.tril().sum()\n    assert L.trace() == M.trace()\n    assert (L == M.tril()).all()\n", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\nimport functools\n\n\nclass TestSolution(unittest.TestCase):\n    def test(self):\n        torch.manual_seed(1)\n        M = torch.randint(0, 10, (5, 5))\n        self.assertEqual(algorithm(M), torch.tril(M))\n\n        torch.manual_seed(2)\n        M = torch.randint(0, 10, (3, 3))\n        self.assertEqual(algorithm(M), torch.tril(M))\n\n        torch.manual_seed(3)\n        M = torch.randint(0, 10, (1, 1))\n        self.assertEqual(algorithm(M), torch.tril(M))\n\n        print('All tests passed!')\n\n\ndef _test_function(test_case):\n    return functools.reduce(lambda x, y: x * y, test_case)\n\n\nif __name__ == '__main__':\n    unittest.main()\n", "\nTest Your Solution:\nYou can test your solution like this:\n```python\nfrom helpers.python_test import test\n\n@test\ndef solution_works():\n    M = torch.randint(0, 10, (5, 5))\n    L = algorithm(M)\n    assert L.shape == (5, 5)\n    assert L.sum() == M.tril().sum()\n    assert L.trace() == M.trace()\n    assert L.sum() == L.trace()\n```\n\n'''\n\nimport torch\n\ndef algorithm(M: torch.Tensor) -> torch.Tensor:\n    '''\n    args:\n        M: torch.Tensor of shape (N, N)\n\n    return:\n        L: torch.Tensor of shape (N, N), which is the lower triangular part of M\n    '''\n    N = M.size(0)\n    L = torch.tensor([[M[i, j] if i <= j else 0 for j in range(N)] for i in range(N)])  \n    return L\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\nimport functools\n\n\nclass TestSolution(unittest.TestCase):\n    def test(self):\n        torch.manual_seed(1)\n        M = torch.randint(-10, 10, (5, 5))\n        self.assertEqual(functools.reduce(lambda x, y: x * y, algorithm(M).shape),\n                         functools.reduce(lambda x, y: x * y, M.shape))\n        self.assertEqual(algorithm(M), torch.tril(M))\n\n        torch.manual_seed(2)\n        M = torch.randint(-10, 10, (10, 10))\n        self.assertEqual(functools.reduce(lambda x, y: x * y, algorithm(M).shape),\n                         functools.reduce(lambda x, y: x * y, M.shape))\n        self.assertEqual(algorithm(M), torch.tril(M))\n\n        torch.manual_seed(3)\n        M = torch.randint(-10, 10, (15, 15))\n        self.assertEqual(functools.reduce(lambda x, y: x * y, algorithm(M).shape),\n                         functools.reduce(lambda x, y: x * y, M.shape))\n        self.assertEqual(algorithm(M), torch.tril(M))\n\n        torch.manual_seed(4)\n        M = torch.randint(-10, 10, (20, 20))\n        self.assertEqual(functools.reduce(lambda x, y: x * y, algorithm(M).shape),\n                         functools.reduce(lambda x, y: x * y, M.shape))\n        self.assertEqual(algorithm(M), torch.tril(M))\n\n        torch.manual_seed(5)\n        M = torch.randint(-10, 10, (25, 25))\n        self.assertEqual(functools.reduce(lambda x, y: x * y, algorithm(M).shape),\n                         functools.reduce(lambda x, y: x * y, M.shape))\n        self.assertEqual(algorithm(M), torch.tril(M))\n\n        print('Passed')\n\n\nif __name__ == '__main__':\n    unittest.main()\n", "\nTest your corrected solution with the provided test cases.\n\nTest Case 1:\n\nInput:\n```python\nM = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n```\n\nOutput:\n```python\ntensor([[1, 0, 0],\n        [4, 5, 0],\n        [7, 8, 9]])\n```\n\nTest Case 2:\n\nInput:\n```python\nM = torch.tensor([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]])\n```\n\nOutput:\n```python\ntensor([[ 1,  0,  0,  0],\n        [ 5,  6,  0,  0],\n        [ 9, 10, 11,  0],\n        [13, 14, 15, 16]])\n```\n\nTest Case 3:\n\nInput:\n```python\nM = torch.tensor([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]])\n```\n\nOutput:\n```python\ntensor([[ 1,  0,  0,  0,  0],\n        [ 6,  7,  0,  0,  0],\n        [11, 12, 13,  0,  0],\n        [16, 17, 18, 19, 20],\n        [21, 22, 23, 24, 25]])\n```\n\nTest Case 4:\n\nInput:\n```python\nM = torch.tensor([[1, 2, 3, 4, 5, 6], [7, 8, 9, 10, 11, 12], [13, 14, 15, 16, 17, 18], [19, 20, 21, 22, 23, 24], [25, 26, 27, 28, 29, 30], [31, 32, 33, 34, 35, 36]])\n```\n\nOutput:\n```python\ntensor([[ 1,  0,  0,  0,  0,  0],\n        [ 7,  8,  0,  0,  0,  0],\n        [13, 14, 15,  0,  0,  0],\n        [19, 20, 21, 22, 23,  0],\n        [25, 26, 27, 28, 29, 30],\n        [31, 32, 33, 34, 35, 36]])\n```\n\nTest Case 5:\n\nInput:\n```python\nM = torch.tensor([[1, 2, 3, 4, 5, 6, 7], [8, 9, 10, 11, 12, 13, 14], [15, 16, 17, 18, 19, 20, 21], [22, 23, 24, 25, 26, 27, 28], [29, 30, 31, 32, 33, 34, 35], [36, 37, 38, 39, 40, 41, 42], [43, 44, 45, 46, 47, 48,", "\nTest your corrected solution with the provided test cases.\n\nTest Case 1:\nInput:\n```python\nM = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n```\n\nOutput:\n```python\ntensor([[1, 0, 0],\n        [4, 5, 0],\n        [7, 8, 9]])\n```\n\nTest Case 2:\nInput:\n```python\nM = torch.tensor([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]])\n```\n\nOutput:\n```python\ntensor([[ 1,  0,  0,  0],\n        [ 5,  6,  0,  0],\n        [ 9, 10, 11,  0],\n        [13, 14, 15, 16]])\n```\n\nTest Case 3:\nInput:\n```python\nM = torch.tensor([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]])\n```\n\nOutput:\n```python\ntensor([[ 1,  0,  0,  0,  0],\n        [ 6,  7,  0,  0,  0],\n        [11, 12, 13,  0,  0],\n        [16, 17, 18, 19, 20],\n        [21, 22, 23, 24, 25]])\n```\n\nTest Case 4:\nInput:\n```python\nM = torch.tensor([[1, 2, 3, 4, 5, 6], [7, 8, 9, 10, 11, 12], [13, 14, 15, 16, 17, 18], [19, 20, 21, 22, 23, 24], [25, 26, 27, 28, 29, 30], [31, 32, 33, 34, 35, 36]])\n```\n\nOutput:\n```python\ntensor([[ 1,  0,  0,  0,  0,  0],\n        [ 7,  8,  0,  0,  0,  0],\n        [13, 14, 15,  0,  0,  0],\n        [19, 20, 21, 22, 23,  0],\n        [25, 26, 27, 28, 29, 30],\n        [31, 32, 33, 34, 35, 36]])\n```\n\nTest Case 5:\nInput:\n```python\nM = torch.tensor([[1, 2, 3, 4, 5, 6, 7], [8, 9, 10, 11, 12, 13, 14], [15, 16, 17, 18, 19, 20, 21], [22, 23, 24, 25, 26, 27, 28], [29, 30, 31, 32, 33, 34, 35], [36, 37, 38, 39, 40, 41, 42], [43, 44, 45, 46, 47, 48, 49]])\n", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\nimport random\n\n\nclass TestSolution(unittest.TestCase):\n    def test_shape(self):\n        for _ in range(20):\n            N = random.randint(1, 100)\n            M = torch.rand(N, N)\n            L = algorithm(M)\n            self.assertEqual(L.shape, (N, N))\n\n    def test_values(self):\n        for _ in range(20):\n            N = random.randint(1, 100)\n            M = torch.rand(N, N)\n            L = algorithm(M)\n            for i in range(N):\n                for j in range(N):\n                    if i <= j:\n                        self.assertEqual(L[i, j], M[i, j])\n                    else:\n                        self.assertEqual(L[i, j], 0)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\nimport functools\n\n\nclass TestSolution(unittest.TestCase):\n    def test(self):\n        torch.manual_seed(1)\n        M = torch.randint(0, 10, (5, 5))\n        self.assertEqual(functools.reduce(torch.add, algorithm(M)), M)\n\n\nif __name__ == '__main__':\n    unittest.main()\n", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Udacityicd\n# Author: Patika Turan\n\nimport torch\n\ndef algorithm(M: torch.Tensor) -> torch.Tensor:\n    '''\n    args:\n        M: torch.Tensor of shape (N, N)\n\n    return:\n        L: torch.Tensor of shape (N, N), which is the lower triangular part of M\n    '''\n    N = M.size(0)\n    L = torch.tensor([[M[i, j] if i <= j else 0 for j in range(N)] for i in range(N)])  \n    return L\n\n\n# test case 1\nprint(algorithm(torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]])))\n\n# test case 2\nprint(algorithm(torch.tensor([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]])))\n", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\nimport random\n\n\nclass TestSolution(unittest.TestCase):\n    def test_shape(self):\n        for _ in range(20):\n            N = random.randint(1, 100)\n            M = torch.rand(N, N)\n            L = algorithm(M)\n            self.assertEqual(L.shape, (N, N))\n\n    def test_values(self):\n        for _ in range(20):\n            N = random.randint(1, 100)\n            M = torch.rand(N, N)\n            L = algorithm(M)\n            for i in range(N):\n                for j in range(N):\n                    if i <= j:\n                        self.assertEqual(L[i, j], M[i, j])\n                    else:\n                        self.assertEqual(L[i, j], 0)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\nimport functools\n\n\nclass TestSolution(unittest.TestCase):\n    def test(self):\n        torch.manual_seed(1)\n        M = torch.randint(-10, 10, (5, 5))\n        self.assertEqual(functools.reduce(lambda x, y: x * y, M.shape), functools.reduce(lambda x, y: x * y, algorithm(M).shape))\n        self.assertEqual(algorithm(M), torch.tril(M))\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n", "\nTest Your Solution:\nYou can test your solution like this:\n```python\nfrom helpers.python_test import test\n\n@test\ndef solution_works():\n    M = torch.randint(0, 10, (5, 5))\n    L = algorithm(M)\n    assert L.shape == (5, 5)\n    assert L.sum() == M.tril().sum()\n```\n'''\n\n\ndef algorithm(M: torch.Tensor) -> torch.Tensor:\n    N = M.size(0)\n    L = torch.tensor([[M[i, j] if i <= j else 0 for j in range(N)] for i in range(N)])\n    return L\n", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\nimport functools\n\n\ndef run(function_to_test, get_args, test_cases, name):\n    failed_test_cases = []\n\n    for index, (args, expected) in enumerate(test_cases):\n        try:\n            result = function_to_test(*args)\n            assert result.allclose(expected), (\n                f\"{name} test {index + 1} failed:\\nExpected\\n{expected}\\nGot\\n{result}\"\n            )\n        except AssertionError as e:\n            failed_test_cases.append(\n                f\"{name} test {index + 1} failed with input {args}:\\n{e}\"\n            )\n\n    if failed_test_cases:\n        msg = \"\\n\\n\".join(failed_test_cases)\n        raise AssertionError(f\"{len(failed_test_cases)} {name} tests failed:\\n{msg}\")\n\n\ndef get_lower_triangular_matrix(M):\n    N = M.size(0)\n    L = torch.tensor([[M[i, j] if i <= j else 0 for j in range(N)] for i in range(N)])\n    return L\n\n\nclass TestAlgorithm(unittest.TestCase):\n    def test_algorithm(self):\n        test_cases = [\n            (\n                (torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),),\n                torch.tensor([[1, 0, 0], [4, 5, 0], [7, 8, 9]]),\n            ),\n            (\n                (torch.tensor([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]),),\n                torch.tensor(\n                    [\n                        [1, 0, 0, 0],\n                        [5, 6, 0, 0],\n                        [9, 10, 11, 0],\n                        [13, 14, 15, 16],\n                    ]\n                ),\n            ),\n        ]\n        run(\n            get_lower_triangular_matrix,\n            functools.partial(get_args, get_lower_triangular_matrix),\n            test_cases,\n            \"get_lower_triangular_matrix\",\n        )\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n", "\nTest Your Solution:\nYou can test your solution like this:\n```python\nfrom helpers.python_test import test\n\n@test\ndef solution_works():\n    M = torch.randint(0, 10, (5, 5))\n    L = algorithm(M)\n    assert L.shape == (5, 5)\n    assert torch.all(L == torch.tril(M))\n```\n'''\n\n\ndef algorithm(M: torch.Tensor) -> torch.Tensor:\n    '''\n    args:\n        M: torch.Tensor of shape (N, N)\n\n    return:\n        L: torch.Tensor of shape (N, N), which is the lower triangular part of M\n    '''\n    N = M.size(0)\n    L = torch.tensor([[M[i, j] if i <= j else 0 for j in range(N)] for i in range(N)])\n    return L\n", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\nimport random\n\n\nclass TestSolution(unittest.TestCase):\n    def test_shape(self):\n        for _ in range(20):\n            N = random.randint(1, 100)\n            M = torch.rand(N, N)\n            L = algorithm(M)\n            self.assertEqual(L.shape, M.shape)\n\n    def test_values(self):\n        for _ in range(20):\n            N = random.randint(1, 100)\n            M = torch.rand(N, N)\n            L = algorithm(M)\n            for i in range(N):\n                for j in range(N):\n                    if i <= j:\n                        self.assertEqual(L[i, j], M[i, j])\n                    else:\n                        self.assertEqual(L[i, j], 0)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\nimport functools\n\n\nclass TestSolution(unittest.TestCase):\n    def test(self):\n        torch.manual_seed(1)\n        M = torch.randint(-10, 10, (5, 5))\n        self.assertEqual(functools.reduce(lambda x, y: x * y, algorithm(M).shape),\n                         functools.reduce(lambda x, y: x * y, M.shape))\n        self.assertEqual(algorithm(M), torch.tril(M))\n\n        torch.manual_seed(2)\n        M = torch.randint(-10, 10, (10, 10))\n        self.assertEqual(functools.reduce(lambda x, y: x * y, algorithm(M).shape),\n                         functools.reduce(lambda x, y: x * y, M.shape))\n        self.assertEqual(algorithm(M), torch.tril(M))\n\n        torch.manual_seed(3)\n        M = torch.randint(-10, 10, (15, 15))\n        self.assertEqual(functools.reduce(lambda x, y: x * y, algorithm(M).shape),\n                         functools.reduce(lambda x, y: x * y, M.shape))\n        self.assertEqual(algorithm(M), torch.tril(M))\n\n        print('All tests passed!')\n\n\nif __name__ == '__main__':\n    unittest.main()\n", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\nimport functools\n\n\nclass TestSolution(unittest.TestCase):\n    def test(self):\n        torch.manual_seed(1)\n        M = torch.randint(0, 10, (5, 5))\n        self.assertEqual(functools.reduce(torch.add, algorithm(M)), M)\n\n\nif __name__ == '__main__':\n    unittest.main()\n", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\nimport functools\n\n\ndef run(function_to_test, get_args, test_cases, name):\n    failed_test_cases = []\n\n    for index, (args, expected) in enumerate(test_cases):\n        try:\n            result = function_to_test(*get_args(args))\n            assert result.allclose(expected), (\n                f\"{name} test {index + 1} failed:\\nExpected\\n{expected}\\nGot\\n{result}\"\n            )\n        except AssertionError as e:\n            failed_test_cases.append(index + 1)\n            print(e)\n\n    if failed_test_cases:\n        print(f\"{len(failed_test_cases)}/{len(test_cases)} {name} test(s) failed:\", end=\"\")\n        [print(f\"{i}\", end=\"\") for i in failed_test_cases]\n        print()\n\n\ndef get_algorithm_args(args):\n    return args\n\n\ndef get_algorithm_kwargs(args):\n    return dict(M=args[0])\n\n\nclass TestAlgorithm(unittest.TestCase):\n    def test_algorithm(self):\n        test_cases = [\n            (([[1, 2, 3], [4, 5, 6], [7, 8, 9]],), [[1, 0, 0], [4, 5, 0], [7, 8, 9]]),\n            (([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]],), [[1, 0, 0], [4, 5, 0], [7, 8, 9], [10, 11, 12]]),\n            (([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15]],), [[1, 0, 0], [4, 5, 0], [7, 8, 9], [10, 11, 12], [13, 14, 15]]),\n            (([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18]],), [[1, 0, 0], [4, 5, 0], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18]]),\n            (([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18], [19, 20, 21]],), [[1, 0, 0], [4, 5, 0], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18], [19, 20, 21]]),\n            (([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18], [19, 20, 21], [22, 23, 24]],), [[1, 0, 0], [4, 5, 0], [7, 8, 9], [10, 11, 12", "\nTest Your Solution:\nYou can test your solution like this:\n```python\nfrom helpers.python_test import test\n\n@pytest.mark.parametrize(\"M,expected\", [\n    (torch.randint(0, 100, (10, 10)), torch.tril(torch.randint(0, 100, (10, 10)))),\n    (torch.randint(0, 100, (20, 20)), torch.tril(torch.randint(0, 100, (20, 20)))),\n    (torch.randint(0, 100, (30, 30)), torch.tril(torch.randint(0, 100, (30, 30)))),\n])\ndef test_algorithm(M, expected):\n    result = algorithm(M)\n    assert torch.all(torch.eq(result, expected))\n```\n\"\"\"\n\nimport torch\n\ndef algorithm(M: torch.Tensor) -> torch.Tensor:\n    '''\n    args:\n        M: torch.Tensor of shape (N, N)\n\n    return:\n        L: torch.Tensor of shape (N, N), which is the lower triangular part of M\n    '''\n    N = M.size(0)\n    L = torch.tensor([[M[i, j] if i <= j else 0 for j in range(N)] for i in range(N)])  \n    return L\n\n\nif __name__ == \"__main__\":\n    test()\n", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\nimport random\n\n\nclass TestSolution(unittest.TestCase):\n    def test_shape(self):\n        for _ in range(20):\n            N = random.randint(1, 100)\n            M = torch.rand(N, N)\n            L = algorithm(M)\n            self.assertEqual(L.shape, M.shape)\n\n    def test_correctness(self):\n        for _ in range(20):\n            N = random.randint(1, 100)\n            M = torch.rand(N, N)\n            L = algorithm(M)\n            for i in range(N):\n                for j in range(N):\n                    if i <= j:\n                        self.assertEqual(L[i, j], M[i, j])\n                    else:\n                        self.assertEqual(L[i, j], 0)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n", "\nTest Your Solution:\n```python\nfrom utils.hog import algorithm\nfrom utils.tests import pyunit_fixture_plus, print_result\nimport torch\n\n@pyunit_fixture_plus\ndef fixture_plus():\n    M = torch.randint(0, 10, (5, 5))\n    return algorithm, (M, )\n\ndef test_correct(fixture_plus):\n    algorithm, (M, ) = fixture_plus\n    L = algorithm(M)\n    assert L.shape == (5, 5)\n    assert torch.all(L == torch.tril(M))\n```\n\"\"\"\n\nimport torch\n\ndef algorithm(M: torch.Tensor) -> torch.Tensor:\n    '''\n    args:\n        M: torch.Tensor of shape (N, N)\n\n    return:\n        L: torch.Tensor of shape (N, N), which is the lower triangular part of M\n    '''\n    N = M.size(0)\n    L = torch.tensor([[M[i, j] if i <= j else 0 for j in range(N)] for i in range(N)])  \n    return L\n\n\nif __name__ == '__main__':\n    from utils.tests import pyunit_fixture_plus, print_result\n    import torch\n\n    @pyunit_fixture_plus\n    def fixture_plus():\n        M = torch.randint(0, 10, (5, 5))\n        return algorithm, (M, )\n\n    def test_correct(fixture_plus):\n        algorithm, (M, ) = fixture_plus\n        L = algorithm(M)\n        assert L.shape == (5, 5)\n        assert torch.all(L == torch.tril(M))\n\n    test_correct()", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\nimport random\n\n\nclass TestSolution(unittest.TestCase):\n    def test_shape(self):\n        for _ in range(20):\n            N = random.randint(1, 100)\n            M = torch.rand(N, N)\n            L = algorithm(M)\n            self.assertEqual(L.shape, M.shape)\n\n    def test_values(self):\n        for _ in range(20):\n            N = random.randint(1, 100)\n            M = torch.rand(N, N)\n            L = algorithm(M)\n            for i in range(N):\n                for j in range(N):\n                    if i <= j:\n                        self.assertEqual(L[i, j], M[i, j])\n                    else:\n                        self.assertEqual(L[i, j], 0)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n", "\nTest Your Solution:\nYou can test your solution like this:\n```python\nfrom helpers.python_test import test\n\n@test\ndef solution_works():\n    M = torch.randint(0, 10, (5, 5))\n    L = algorithm(M)\n    assert L.shape == (5, 5)\n    assert L.sum() == M.tril().sum()\n    assert (L == M.tril()).all()\n```\n'''\n\n# Solution\nimport torch\n\ndef algorithm(M: torch.Tensor) -> torch.Tensor:\n    '''\n    args:\n        M: torch.Tensor of shape (N, N)\n\n    return:\n        L: torch.Tensor of shape (N, N), which is the lower triangular part of M\n    '''\n    N = M.size(0)\n    L = torch.tensor([[M[i, j] if i <= j else 0 for j in range(N)] for i in range(N)])  \n    return L\n\n# Test your solution\nfrom helpers.python_test import test\n\n@test\ndef solution_works():\n    M = torch.randint(0, 10, (5, 5))\n    L = algorithm(M)\n    assert L.shape == (5, 5)\n    assert L.sum() == M.tril().sum()\n    assert (L == M.tril()).all()", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\n\n\nclass TestSolution(unittest.TestCase):\n    def test_shape(self):\n        self.assertEqual(algorithm(torch.randint(0, 10, (5, 5))).shape, (5, 5))\n        self.assertEqual(algorithm(torch.randint(0, 10, (3, 3))).shape, (3, 3))\n        self.assertEqual(algorithm(torch.randint(0, 10, (1, 1))).shape, (1, 1))\n        self.assertEqual(algorithm(torch.randint(0, 10, (2, 2))).shape, (2, 2))\n\n    def test_values(self):\n        self.assertEqual(algorithm(torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]])),\n                         torch.tensor([[1, 0, 0], [4, 5, 0], [7, 8, 9]]))\n        self.assertEqual(algorithm(torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]])),\n                         torch.tensor([[1, 0, 0], [4, 5, 0], [7, 8, 9]]))\n        self.assertEqual(algorithm(torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]])),\n                         torch.tensor([[1, 0, 0], [4, 5, 0], [7, 8, 9]]))\n        self.assertEqual(algorithm(torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]])),\n                         torch.tensor([[1, 0, 0], [4, 5, 0], [7, 8, 9]]))\n\n\nif __name__ == '__main__':\n    unittest.main()\n", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\n\nclass TestSolution(unittest.TestCase):\n    def test1(self):\n        M = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n        self.assertEqual(algorithm(M), torch.tensor([[1, 0, 0], [4, 5, 0], [7, 8, 9]]))\n\n    def test2(self):\n        M = torch.tensor([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]])\n        self.assertEqual(algorithm(M), torch.tensor([[1, 0, 0, 0], [5, 6, 0, 0], [9, 10, 11, 0], [13, 14, 15, 16]]))\n\n    def test3(self):\n        M = torch.tensor([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]])\n        self.assertEqual(algorithm(M), torch.tensor([[1, 0, 0, 0, 0], [6, 7, 0, 0, 0], [11, 12, 13, 0, 0], [16, 17, 18, 19, 0], [21, 22, 23, 24, 25]]))\n\n    def test4(self):\n        M = torch.tensor([[1, 2, 3, 4, 5, 6], [7, 8, 9, 10, 11, 12], [13, 14, 15, 16, 17, 18], [19, 20, 21, 22, 23, 24], [25, 26, 27, 28, 29, 30], [31, 32, 33, 34, 35, 36]])\n        self.assertEqual(algorithm(M), torch.tensor([[1, 0, 0, 0, 0, 0], [7, 8, 0, 0, 0, 0], [13, 14, 15, 0, 0, 0], [19, 20, 21, 22, 0, 0], [25, 26, 27, 28, 29, 0], [31, 32, 33, 34, 35, 36]]))\n\n    def test5(self):\n        M = torch.tensor([[1, 2, 3, 4, 5, 6, 7], [8, 9, 10, 11, 12, 13, 14], [15, 16, 17, 18, 19, 20, 21], [22, 23, 24, 25, 26, 27, 28], [29, 30, 31, 32, 33, 34, 35], [36, 37, 38, 39, 40, 41, 42], [43, 44, 45, 46, 47, 48, 49]])\n", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\n\nclass TestSolution(unittest.TestCase):\n    def test1(self):\n        self.assertEqual(algorithm(torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]])),\n                         torch.tensor([[1, 0, 0], [4, 5, 0], [7, 8, 9]]))\n\n    def test2(self):\n        self.assertEqual(algorithm(torch.tensor([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]])),\n                         torch.tensor([[1, 0, 0, 0], [5, 6, 0, 0], [9, 10, 11, 0], [13, 14, 15, 16]]))\n\n    def test3(self):\n        self.assertEqual(algorithm(torch.tensor([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]])),\n                         torch.tensor([[1, 0, 0, 0, 0], [6, 7, 0, 0, 0], [11, 12, 13, 0, 0], [16, 17, 18, 19, 0], [21, 22, 23, 24, 25]]))\n\n    def test4(self):\n        self.assertEqual(algorithm(torch.tensor([[1, 2, 3, 4, 5, 6], [7, 8, 9, 10, 11, 12], [13, 14, 15, 16, 17, 18], [19, 20, 21, 22, 23, 24], [25, 26, 27, 28, 29, 30], [31, 32, 33, 34, 35, 36]])),\n                         torch.tensor([[1, 0, 0, 0, 0, 0], [7, 8, 0, 0, 0, 0], [13, 14, 15, 0, 0, 0], [19, 20, 21, 22, 0, 0], [25, 26, 27, 28, 29, 0], [31, 32, 33, 34, 35, 36]]))\n\n\nif __name__ == \"__main__\":\n    unittest.main()", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\nimport functools\n\n\nclass TestSolution(unittest.TestCase):\n    def test(self):\n        torch.manual_seed(1)\n        N = torch.randint(1, 10, (1,)).item()\n        M = torch.randint(-10, 10, (N, N))\n        self.assertEqual(functools.reduce(torch.add, (M[i, j] if i <= j else 0 for i in range(N) for j in range(N))).item(),\n                         algorithm(M).sum().item())\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\nimport random\n\n\nclass TestSolution(unittest.TestCase):\n    def test_shape(self):\n        N = random.randint(1, 10)\n        M = torch.rand(N, N)\n        L = algorithm(M)\n        self.assertEqual(L.shape, M.shape)\n\n    def test_lower_triangular(self):\n        N = random.randint(1, 10)\n        M = torch.rand(N, N)\n        L = algorithm(M)\n        for i in range(N):\n            for j in range(N):\n                if i <= j:\n                    self.assertEqual(L[i, j], M[i, j])\n                else:\n                    self.assertEqual(L[i, j], 0)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\n\nclass TestSolution(unittest.TestCase):\n    def test1(self):\n        M = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n        self.assertEqual(algorithm(M), torch.tensor([[1, 0, 0], [4, 5, 0], [7, 8, 9]]))\n\n    def test2(self):\n        M = torch.tensor([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]])\n        self.assertEqual(algorithm(M), torch.tensor([[1, 0, 0, 0], [5, 6, 0, 0], [9, 10, 11, 0], [13, 14, 15, 16]]))\n\n    def test3(self):\n        M = torch.tensor([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]])\n        self.assertEqual(algorithm(M), torch.tensor([[1, 0, 0, 0, 0], [6, 7, 0, 0, 0], [11, 12, 13, 0, 0], [16, 17, 18, 19, 0], [21, 22, 23, 24, 25]]))\n\n    def test4(self):\n        M = torch.tensor([[1, 2, 3, 4, 5, 6], [7, 8, 9, 10, 11, 12], [13, 14, 15, 16, 17, 18], [19, 20, 21, 22, 23, 24], [25, 26, 27, 28, 29, 30], [31, 32, 33, 34, 35, 36]])\n        self.assertEqual(algorithm(M), torch.tensor([[1, 0, 0, 0, 0, 0], [7, 8, 0, 0, 0, 0], [13, 14, 15, 0, 0, 0], [19, 20, 21, 22, 0, 0], [25, 26, 27, 28, 29, 0], [31, 32, 33, 34, 35, 36]]))\n\n    def test5(self):\n        M = torch.tensor([[1, 2, 3, 4, 5, 6, 7], [8, 9, 10, 11, 12, 13, 14], [15, 16, 17, 18, 19, 20, 21], [22, 23, 24, 25, 26, 27, 28], [29, 30, 31, 32, 33, 34, 35], [36, 37, 38, 39, 40, 41, 42], [43, 44, 45, 46, 47, 48, 49]])\n", "\nTest Your Solution:\n```python\nfrom utils.hog import algorithm\nfrom utils.tests import pyunit_fixture_plus, get_test_file\n\n@pyunit_fixture_plus\ndef fixture_plus():\n    M = torch.load(get_test_file('M.pt'))\n    L = torch.load(get_test_file('L.pt'))\n    return M, L\n\ndef test_fixture_plus(fixture_plus):\n    M, L = fixture_plus\n    assert algorithm(M).equal(L)\n```\n\"\"\"\n\nimport torch\n\ndef algorithm(M: torch.Tensor) -> torch.Tensor:\n    '''\n    args:\n        M: torch.Tensor of shape (N, N)\n\n    return:\n        L: torch.Tensor of shape (N, N), which is the lower triangular part of M\n    '''\n    N = M.size(0)\n    L = torch.tensor([[M[i, j] if i <= j else 0 for j in range(N)] for i in range(N)])  \n    return L\n\n\nif __name__ == '__main__':\n    from utils.tests import test_all\n    test_all(globals())\n", "\nTest Your Solution:\n```python\nfrom utils.hog import algorithm\nfrom utils.tests import pyunit_fixture_plus, print_result\nimport torch\n\n@pyunit_fixture_plus\ndef fixture_plus():\n    M = torch.randint(0, 10, (5, 5))\n    return algorithm, (M, )\n\ndef test_correct(fixture_plus):\n    algorithm, (M, ) = fixture_plus\n    L = algorithm(M)\n    assert L.shape == (5, 5)\n    assert torch.all(L == torch.tril(M))\n```\n\"\"\"\n\nimport torch\n\ndef algorithm(M: torch.Tensor) -> torch.Tensor:\n    '''\n    args:\n        M: torch.Tensor of shape (N, N)\n\n    return:\n        L: torch.Tensor of shape (N, N), which is the lower triangular part of M\n    '''\n    N = M.size(0)\n    L = torch.tensor([[M[i, j] if i <= j else 0 for j in range(N)] for i in range(N)])  \n    return L\n\n\n# PyUnit Conformance Tests\nfrom utils.tests import pyunit_fixture_plus, print_result\nimport torch\n\n@pyunit_fixture_plus\ndef fixture_plus():\n    M = torch.randint(0, 10, (5, 5))\n    return algorithm, (M, )\n\ndef test_correct(fixture_plus):\n    algorithm, (M, ) = fixture_plus\n    L = algorithm(M)\n    assert L.shape == (5, 5)\n    assert torch.all(L == torch.tril(M))\n\n\n# PyBit Token Tests\nfrom utils.tests import pybit_fixture_plus, print_result\nimport torch\n\n@pybit_fixture_plus\ndef fixture_plus():\n    M = torch.randint(0, 10, (5, 5))\n    return algorithm, (M, )\n\ndef test_correct(fixture_plus):\n    algorithm, (M, ) = fixture_plus\n    L = algorithm(M)\n    assert L.shape == (5, 5)\n    assert torch.all(L == torch.tril(M))\n\n\n# PyBit Token Tests\nfrom utils.tests import pytorch_fixture_plus, print_result\nimport torch\n\n@pytorch_fixture_plus\ndef fixture_plus():\n    M = torch.randint(0, 10, (5, 5))\n    return algorithm, (M, )\n\ndef test_correct(fixture_plus):\n    algorithm, (M, ) = fixture_plus\n    L = algorithm(M)\n    assert L.shape == (5, 5)\n    assert torch.all(L == torch.tril(M))\n\n\n# NumPy Conformance Tests\nfrom utils.tests import numpy_fixture_plus, print_result\nimport numpy as np\n\n@numpy_fixture_plus\ndef fixture_plus():\n    M = np.random.randint(0, 10, (5, 5))\n    return algorithm, (M, )\n\ndef test_correct(fixture_plus):\n    algorithm, (M, ) = fixture_plus\n    L = algorithm(M)\n    assert L.shape == (5, 5)\n    assert np.all(L == np.tril(M))\n\n\n# NumPy Conformance Tests\nfrom utils.tests import jax_fixture_plus, print_result\nimport jax.numpy as jnp\n\n@jax_fixture_plus\ndef fixture_plus():\n    M = jnp.random.randint(0, 10, (5, 5))\n    return algorithm, (M, )\n\ndef test_correct(fixture_plus):\n    algorithm, (M, ) = fixture_plus\n    L = algorithm(M)\n    assert L.shape == (5, 5)\n    assert j", "\nTest Your Solution:\nYou can test your solution like this:\n```python\nfrom helpers.python_test import test\n\n@test\ndef solution_works():\n    M = torch.randint(0, 10, (5, 5))\n    L = algorithm(M)\n    assert L.shape == (5, 5)\n    assert torch.all(L == torch.tril(M))\n```\n'''\n\n\ndef algorithm(M: torch.Tensor) -> torch.Tensor:\n    '''\n    args:\n        M: torch.Tensor of shape (N, N)\n\n    return:\n        L: torch.Tensor of shape (N, N), which is the lower triangular part of M\n    '''\n    N = M.size(0)\n    L = torch.tensor([[M[i, j] if i <= j else 0 for j in range(N)] for i in range(N)])\n    return L\n", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\nimport functools\n\n\nclass TestSolution(unittest.TestCase):\n    def test(self):\n        torch.manual_seed(1)\n        M = torch.randint(-10, 10, (5, 5))\n        self.assertEqual(functools.reduce(lambda x, y: x * y, algorithm(M).shape),\n                         functools.reduce(lambda x, y: x * y, M.shape))\n        self.assertEqual(algorithm(M), torch.tril(M))\n\n        torch.manual_seed(2)\n        M = torch.randint(-10, 10, (10, 10))\n        self.assertEqual(functools.reduce(lambda x, y: x * y, algorithm(M).shape),\n                         functools.reduce(lambda x, y: x * y, M.shape))\n        self.assertEqual(algorithm(M), torch.tril(M))\n\n        torch.manual_seed(3)\n        M = torch.randint(-10, 10, (15, 15))\n        self.assertEqual(functools.reduce(lambda x, y: x * y, algorithm(M).shape),\n                         functools.reduce(lambda x, y: x * y, M.shape))\n        self.assertEqual(algorithm(M), torch.tril(M))\n\n        print('All tests passed!')\n\n\ndef algorithm(M: torch.Tensor) -> torch.Tensor:\n    '''\n    args:\n        M: torch.Tensor of shape (N, N)\n\n    return:\n        L: torch.Tensor of shape (N, N), which is the lower triangular part of M\n    '''\n    # Your code goes here!\n    N = M.size(0)\n    L = torch.tensor([[M[i, j] if i <= j else 0 for j in range(N)] for i in range(N)])\n    return L\n\n\nif __name__ == '__main__':\n    unittest.main()\n", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\nimport functools\n\n\nclass TestSolution(unittest.TestCase):\n    def test(self):\n        torch.manual_seed(1)\n        N = torch.randint(3, 6, (1,)).item()\n        M = torch.rand(N, N)\n        L = algorithm(M)\n        self.assertEqual(L.shape, (N, N))\n        self.assertEqual(L.sum(), M.sum())\n        self.assertEqual(L.triu().sum(), 0)\n\n        torch.manual_seed(2)\n        N = torch.randint(3, 6, (1,)).item()\n        M = torch.rand(N, N)\n        L = algorithm(M)\n        self.assertEqual(L.shape, (N, N))\n        self.assertEqual(L.sum(), M.sum())\n        self.assertEqual(L.triu().sum(), 0)\n\n        torch.manual_seed(3)\n        N = torch.randint(3, 6, (1,)).item()\n        M = torch.rand(N, N)\n        L = algorithm(M)\n        self.assertEqual(L.shape, (N, N))\n        self.assertEqual(L.sum(), M.sum())\n        self.assertEqual(L.triu().sum(), 0)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\nimport random\n\n\nclass TestSolution(unittest.TestCase):\n    def test_shape(self):\n        for _ in range(20):\n            N = random.randint(1, 100)\n            M = torch.rand(N, N)\n            L = algorithm(M)\n            self.assertEqual(L.shape, M.shape)\n\n    def test_values(self):\n        for _ in range(20):\n            N = random.randint(1, 100)\n            M = torch.rand(N, N)\n            L = algorithm(M)\n            for i in range(N):\n                for j in range(N):\n                    if i <= j:\n                        self.assertEqual(L[i, j], M[i, j])\n                    else:\n                        self.assertEqual(L[i, j], 0)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\nimport random\n\n\nclass TestSolution(unittest.TestCase):\n    def test_shape(self):\n        for _ in range(20):\n            N = random.randint(1, 100)\n            M = torch.rand(N, N)\n            L = algorithm(M)\n            self.assertEqual(L.shape, M.shape)\n\n    def test_values(self):\n        for _ in range(20):\n            N = random.randint(1, 100)\n            M = torch.rand(N, N)\n            L = algorithm(M)\n            for i in range(N):\n                for j in range(N):\n                    if i <= j:\n                        self.assertEqual(L[i, j], M[i, j])\n                    else:\n                        self.assertEqual(L[i, j], 0)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n", "\nTest Your Solution:\nYou can test your solution like this:\n```python\nfrom helpers.python_test import test\n\n@test\ndef solution_works():\n    M = torch.randint(0, 10, (5, 5))\n    L = algorithm(M)\n    assert L.shape == (5, 5)\n    assert L.sum() == M.tril().sum()\n```\n'''\n\n# Solution\nimport torch\n\ndef algorithm(M: torch.Tensor) -> torch.Tensor:\n    '''\n    args:\n        M: torch.Tensor of shape (N, N)\n\n    return:\n        L: torch.Tensor of shape (N, N), which is the lower triangular part of M\n    '''\n    N = M.size(0)\n    L = torch.tensor([[M[i, j] if i <= j else 0 for j in range(N)] for i in range(N)])  \n    return L\n\n# Test your solution\nM = torch.randint(0, 10, (5, 5))\nL = algorithm(M)\nassert L.shape == (5, 5)\nassert L.sum() == M.tril().sum()\n", "\nTest your corrected solution with the provided test cases.\n\nTest Case 1:\n\nInput:\n```python\nM = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n```\n\nOutput:\n```python\ntensor([[1, 0, 0],\n        [4, 5, 0],\n        [7, 8, 9]])\n```\n\nTest Case 2:\n\nInput:\n```python\nM = torch.tensor([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]])\n```\n\nOutput:\n```python\ntensor([[ 1,  0,  0,  0],\n        [ 5,  6,  0,  0],\n        [ 9, 10, 11,  0],\n        [13, 14, 15, 16]])\n```\n\nTest Case 3:\n\nInput:\n```python\nM = torch.tensor([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]])\n```\n\nOutput:\n```python\ntensor([[ 1,  0,  0,  0,  0],\n        [ 6,  7,  0,  0,  0],\n        [11, 12, 13,  0,  0],\n        [16, 17, 18, 19, 20],\n        [21, 22, 23, 24, 25]])\n```\n\nTest Case 4:\n\nInput:\n```python\nM = torch.tensor([[1, 2, 3, 4, 5, 6], [7, 8, 9, 10, 11, 12], [13, 14, 15, 16, 17, 18], [19, 20, 21, 22, 23, 24], [25, 26, 27, 28, 29, 30], [31, 32, 33, 34, 35, 36]])\n```\n\nOutput:\n```python\ntensor([[ 1,  0,  0,  0,  0,  0],\n        [ 7,  8,  0,  0,  0,  0],\n        [13, 14, 15,  0,  0,  0],\n        [19, 20, 21, 22, 23,  0],\n        [25, 26, 27, 28, 29, 30],\n        [31, 32, 33, 34, 35, 36]])\n```\n\nTest Case 5:\n\nInput:\n```python\nM = torch.tensor([[1, 2, 3, 4, 5, 6, 7], [8, 9, 10, 11, 12, 13, 14], [15, 16, 17, 18, 19, 20, 21], [22, 23, 24, 25, 26, 27, 28], [29, 30, 31, 32, 33, 34, 35], [36, 37, 38, 39, 40, 41, 42], [43, 44, 45, 46, 47, 48,", "\nTest Your Solution:\n```python\nfrom utils.hog import algorithm\nfrom utils.tests import pyunit_fixture_plus, print_result\nimport torch\n\n@pyunit_fixture_plus\ndef fixture_plus():\n    M = torch.randint(0, 10, (5, 5))\n    return algorithm, (M, )\n\ndef test_correct(fixture_plus):\n    algorithm, (M, ) = fixture_plus\n    L = algorithm(M)\n    assert L.size() == (5, 5)\n    assert torch.all(L == torch.tril(M))\n    print_result(L)\n```\n\"\"\"\nimport torch\n\ndef algorithm(M: torch.Tensor) -> torch.Tensor:\n    '''\n    args:\n        M: torch.Tensor of shape (N, N)\n\n    return:\n        L: torch.Tensor of shape (N, N), which is the lower triangular part of M\n    '''\n    N = M.size(0)\n    L = torch.tensor([[M[i, j] if i <= j else 0 for j in range(N)] for i in range(N)])  \n    return L\n\n\nif __name__ == \"__main__\":\n    from utils.tests import pyunit_fixture_plus, print_result\n    import torch\n\n    @pyunit_fixture_plus\n    def fixture_plus():\n        M = torch.randint(0, 10, (5, 5))\n        return algorithm, (M, )\n\n    def test_correct(fixture_plus):\n        algorithm, (M, ) = fixture_plus\n        L = algorithm(M)\n        assert L.size() == (5, 5)\n        assert torch.all(L == torch.tril(M))\n        print_result(L)\n\n    test_correct()", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\nimport functools\n\n\nclass TestSolution(unittest.TestCase):\n    def test(self):\n        torch.manual_seed(1)\n        N = torch.randint(1, 10, (1,))\n        M = torch.rand(N, N)\n        self.assertEqual(functools.reduce(torch.add, [M[i, j] if i <= j else 0 for i in range(N) for j in range(N)]).item(),\n                         algorithm(M).sum().item())\n\n\nif __name__ == '__main__':\n    unittest.main()\n", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\nimport random\n\n\nclass TestSolution(unittest.TestCase):\n    def test_shape(self):\n        for _ in range(20):\n            N = random.randint(1, 100)\n            M = torch.rand(N, N)\n            L = algorithm(M)\n            self.assertEqual(L.shape, (N, N))\n\n    def test_values(self):\n        for _ in range(20):\n            N = random.randint(1, 100)\n            M = torch.rand(N, N)\n            L = algorithm(M)\n            for i in range(N):\n                for j in range(N):\n                    if i <= j:\n                        self.assertEqual(L[i, j], M[i, j])\n                    else:\n                        self.assertEqual(L[i, j], 0)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\nimport random\n\n\nclass TestSolution(unittest.TestCase):\n    def test_shape(self):\n        for _ in range(20):\n            N = random.randint(1, 100)\n            M = torch.rand(N, N)\n            L = algorithm(M)\n            self.assertEqual(L.shape, M.shape)\n\n    def test_values(self):\n        for _ in range(20):\n            N = random.randint(1, 100)\n            M = torch.rand(N, N)\n            L = algorithm(M)\n            for i in range(N):\n                for j in range(N):\n                    if i <= j:\n                        self.assertEqual(L[i, j], M[i, j])\n                    else:\n                        self.assertEqual(L[i, j], 0)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n", "\nTest your corrected solution with the provided test cases.\n\nTest Case 1:\n\nInput:\n```python\nM = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n```\n\nOutput:\n```python\ntensor([[1, 0, 0],\n        [4, 5, 0],\n        [7, 8, 9]])\n```\n\nTest Case 2:\n\nInput:\n```python\nM = torch.tensor([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]])\n```\n\nOutput:\n```python\ntensor([[ 1,  0,  0,  0],\n        [ 5,  6,  0,  0],\n        [ 9, 10, 11,  0],\n        [13, 14, 15, 16]])\n```\n\nTest Case 3:\n\nInput:\n```python\nM = torch.tensor([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]])\n```\n\nOutput:\n```python\ntensor([[ 1,  0,  0,  0,  0],\n        [ 6,  7,  0,  0,  0],\n        [11, 12, 13,  0,  0],\n        [16, 17, 18, 19, 20],\n        [21, 22, 23, 24, 25]])\n```\n\nTest Case 4:\n\nInput:\n```python\nM = torch.tensor([[1, 2, 3, 4, 5, 6], [7, 8, 9, 10, 11, 12], [13, 14, 15, 16, 17, 18], [19, 20, 21, 22, 23, 24], [25, 26, 27, 28, 29, 30], [31, 32, 33, 34, 35, 36]])\n```\n\nOutput:\n```python\ntensor([[ 1,  0,  0,  0,  0,  0],\n        [ 7,  8,  0,  0,  0,  0],\n        [13, 14, 15,  0,  0,  0],\n        [19, 20, 21, 22, 23,  0],\n        [25, 26, 27, 28, 29, 30],\n        [31, 32, 33, 34, 35, 36]])\n```\n\nTest Case 5:\n\nInput:\n```python\nM = torch.tensor([[1, 2, 3, 4, 5, 6, 7], [8, 9, 10, 11, 12, 13, 14], [15, 16, 17, 18, 19, 20, 21], [22, 23, 24, 25, 26, 27, 28], [29, 30, 31, 32, 33, 34, 35], [36, 37, 38, 39, 40, 41, 42], [43, 44, 45, 46, 47, 48,", "\nTest Your Solution:\nYou can test your solution like this:\n```python\nfrom helpers.python_test import test\n\n@test\ndef solution_works():\n    M = torch.randint(0, 10, (5, 5))\n    L = algorithm(M)\n    assert L.shape == (5, 5)\n    assert L.sum() == M.tril().sum()\n```\n'''\n\n# Solution\nimport torch\n\ndef algorithm(M: torch.Tensor) -> torch.Tensor:\n    '''\n    args:\n        M: torch.Tensor of shape (N, N)\n\n    return:\n        L: torch.Tensor of shape (N, N), which is the lower triangular part of M\n    '''\n    N = M.size(0)\n    L = torch.tensor([[M[i, j] if i <= j else 0 for j in range(N)] for i in range(N)])  \n    return L\n\n# Test your solution\nM = torch.randint(0, 10, (5, 5))\nL = algorithm(M)\nassert L.shape == (5, 5)\nassert L.sum() == M.tril().sum()\n", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\nimport functools\n\n\ndef run(function_to_test, get_args, test_cases, name):\n    failed_test_cases = []\n\n    for index, (args, expected) in enumerate(test_cases):\n        try:\n            result = function_to_test(*args)\n            assert result.allclose(expected), (\n                f\"{name} test {index + 1} failed:\\nExpected\\n{expected}\\nGot\\n{result}\"\n            )\n        except AssertionError as e:\n            failed_test_cases.append(\n                f\"{name} test {index + 1} failed with input {args}:\\n{e}\"\n            )\n\n    if failed_test_cases:\n        msg = \"\\n\\n\".join(failed_test_cases)\n        raise AssertionError(f\"{len(failed_test_cases)} {name} tests failed:\\n{msg}\")\n\n\ndef test_algorithm(M):\n    N = M.size(0)\n    L = torch.tensor([[M[i, j] if i <= j else 0 for j in range(N)] for i in range(N)])\n    return L\n\n\nclass TestAlgorithm(unittest.TestCase):\n    def test_algorithm(self):\n        test_cases = [\n            (\n                (torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),),\n                torch.tensor([[1, 0, 0], [4, 5, 0], [7, 8, 9]]),\n            ),\n            (\n                (torch.tensor([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]),),\n                torch.tensor(\n                    [\n                        [1, 0, 0, 0],\n                        [5, 6, 0, 0],\n                        [9, 10, 11, 0],\n                        [13, 14, 15, 16],\n                    ]\n                ),\n            ),\n        ]\n        run(\n            test_algorithm,\n            functools.partial(test_algorithm, get_args=lambda M: (M,)),\n            test_cases,\n            \"algorithm\",\n        )\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\nimport functools\n\n\ndef run(function_to_test, get_args, test_cases, name):\n    failed_test_cases = []\n\n    for index, (args, expected) in enumerate(test_cases):\n        try:\n            result = function_to_test(*get_args(args))\n            assert result.allclose(expected), (\n                f\"{name} test {index + 1} failed:\\nExpected\\n{expected}\\nGot\\n{result}\"\n            )\n        except AssertionError as e:\n            failed_test_cases.append(index + 1)\n            print(e)\n\n    if failed_test_cases:\n        print(f\"{len(failed_test_cases)}/{len(test_cases)} {name} test(s) failed:\", end=\"\")\n        [print(f\"{i}\", end=\"\") for i in failed_test_cases]\n        print()\n\n\ndef get_algorithm_args(args):\n    return args\n\n\ndef get_algorithm_kwargs(args):\n    return dict(M=args[0])\n\n\nclass TestAlgorithm(unittest.TestCase):\n    def test_algorithm(self):\n        test_cases = [\n            (([[[1, 2, 3], [4, 5, 6], [7, 8, 9]]],), [[1, 0, 0], [4, 5, 0], [7, 8, 9]]),\n            (([[[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]]],), [[1, 0, 0], [4, 5, 0], [7, 8, 9], [10, 11, 12]]),\n            (([[[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15]]],), [[1, 0, 0], [4, 5, 0], [7, 8, 9], [10, 11, 12], [13, 14, 15]]),\n            (([[[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18]]],), [[1, 0, 0], [4, 5, 0], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18]]),\n            (([[[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18], [19, 20, 21]]],), [[1, 0, 0], [4, 5, 0], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18], [19, 20, 21]]),\n            (([[[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18], [19, 20, 21], [22, 23, 24]]],), [[1, 0, 0], [4, 5, 0], [7, 8, 9], [10, ", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\nimport functools\n\n\ndef run(function_to_test, get_args, test_cases, name):\n    failed_test_cases = []\n\n    for index, (args, expected) in enumerate(test_cases):\n        try:\n            result = function_to_test(*args)\n            assert result.allclose(expected), (\n                f\"{name} test {index + 1} failed:\\nExpected\\n{expected}\\nGot\\n{result}\"\n            )\n        except AssertionError as e:\n            failed_test_cases.append(\n                f\"{name} test {index + 1} failed with input {args}:\\n{e}\"\n            )\n\n    if failed_test_cases:\n        msg = \"\\n\\n\".join(failed_test_cases)\n        raise AssertionError(f\"{len(failed_test_cases)} {name} tests failed:\\n{msg}\")\n\n\ndef get_lower_triangular_part_test_cases():\n    # test_cases: [(test_input, expected_result), ...]\n    test_cases = [\n        (([[1, 2, 3], [4, 5, 6], [7, 8, 9]],), [[1, 0, 0], [4, 5, 0], [7, 8, 9]]),\n        (([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]],), [[1, 0, 0], [4, 5, 0], [7, 8, 9], [10, 11, 12]]),\n        (([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15]],), [[1, 0, 0], [4, 5, 0], [7, 8, 9], [10, 11, 12], [13, 14, 15]]),\n        (([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18]],), [[1, 0, 0], [4, 5, 0], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18]]),\n        (([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18], [19, 20, 21]],), [[1, 0, 0], [4, 5, 0], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18], [19, 20, 21]]),\n        (([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18], [19, 20, 21], [22, 23, 24]],), [[1, 0, 0], [4, 5, 0], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18], [19, ", "\nTest your corrected solution with the provided test cases.\n\nTest Case 1:\nInput:\n```python\nM = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n```\n\nOutput:\n```python\ntensor([[1, 0, 0],\n        [4, 5, 0],\n        [7, 8, 9]])\n```\n\nTest Case 2:\nInput:\n```python\nM = torch.tensor([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]])\n```\n\nOutput:\n```python\ntensor([[ 1,  0,  0,  0],\n        [ 5,  6,  0,  0],\n        [ 9, 10, 11,  0],\n        [13, 14, 15, 16]])\n```\n\nTest Case 3:\nInput:\n```python\nM = torch.tensor([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]])\n```\n\nOutput:\n```python\ntensor([[ 1,  0,  0,  0,  0],\n        [ 6,  7,  0,  0,  0],\n        [11, 12, 13,  0,  0],\n        [16, 17, 18, 19, 20],\n        [21, 22, 23, 24, 25]])\n```\n\nTest Case 4:\nInput:\n```python\nM = torch.tensor([[1, 2, 3, 4, 5, 6], [7, 8, 9, 10, 11, 12], [13, 14, 15, 16, 17, 18], [19, 20, 21, 22, 23, 24], [25, 26, 27, 28, 29, 30], [31, 32, 33, 34, 35, 36]])\n```\n\nOutput:\n```python\ntensor([[ 1,  0,  0,  0,  0,  0],\n        [ 7,  8,  0,  0,  0,  0],\n        [13, 14, 15,  0,  0,  0],\n        [19, 20, 21, 22, 23,  0],\n        [25, 26, 27, 28, 29, 30],\n        [31, 32, 33, 34, 35, 36]])\n```\n\nTest Case 5:\nInput:\n```python\nM = torch.tensor([[1, 2, 3, 4, 5, 6, 7], [8, 9, 10, 11, 12, 13, 14], [15, 16, 17, 18, 19, 20, 21], [22, 23, 24, 25, 26, 27, 28], [29, 30, 31, 32, 33, 34, 35], [36, 37, 38, 39, 40, 41, 42], [43, 44, 45, 46, 47, 48, 49]])\n", "\nTest your corrected solution with the provided test cases.\n\nTest Case 1:\nInput:\n```python\nM = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n```\n\nOutput:\n```python\ntensor([[1, 0, 0],\n        [4, 5, 0],\n        [7, 8, 9]])\n```\n\nTest Case 2:\nInput:\n```python\nM = torch.tensor([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]])\n```\n\nOutput:\n```python\ntensor([[ 1,  0,  0,  0],\n        [ 5,  6,  0,  0],\n        [ 9, 10, 11,  0],\n        [13, 14, 15, 16]])\n```\n\nTest Case 3:\nInput:\n```python\nM = torch.tensor([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]])\n```\n\nOutput:\n```python\ntensor([[ 1,  0,  0,  0,  0],\n        [ 6,  7,  0,  0,  0],\n        [11, 12, 13,  0,  0],\n        [16, 17, 18, 19, 20],\n        [21, 22, 23, 24, 25]])\n```\n\nTest Case 4:\nInput:\n```python\nM = torch.tensor([[1, 2, 3, 4, 5, 6], [7, 8, 9, 10, 11, 12], [13, 14, 15, 16, 17, 18], [19, 20, 21, 22, 23, 24], [25, 26, 27, 28, 29, 30], [31, 32, 33, 34, 35, 36]])\n```\n\nOutput:\n```python\ntensor([[ 1,  0,  0,  0,  0,  0],\n        [ 7,  8,  0,  0,  0,  0],\n        [13, 14, 15,  0,  0,  0],\n        [19, 20, 21, 22, 23,  0],\n        [25, 26, 27, 28, 29, 30],\n        [31, 32, 33, 34, 35, 36]])\n```\n\nTest Case 5:\nInput:\n```python\nM = torch.tensor([[1, 2, 3, 4, 5, 6, 7], [8, 9, 10, 11, 12, 13, 14], [15, 16, 17, 18, 19, 20, 21], [22, 23, 24, 25, 26, 27, 28], [29, 30, 31, 32, 33, 34, 35], [36, 37, 38, 39, 40, 41, 42], [43, 44, 45, 46, 47, 48, 49]])\n", "\nTest your corrected solution with the provided test cases.\n\nTest Case 1:\nInput:\n```python\nM = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n```\n\nOutput:\n```python\ntensor([[1, 0, 0],\n        [4, 5, 0],\n        [7, 8, 9]])\n```\n\nTest Case 2:\nInput:\n```python\nM = torch.tensor([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]])\n```\n\nOutput:\n```python\ntensor([[ 1,  0,  0,  0],\n        [ 5,  6,  0,  0],\n        [ 9, 10, 11,  0],\n        [13, 14, 15, 16]])\n```\n\nTest Case 3:\nInput:\n```python\nM = torch.tensor([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]])\n```\n\nOutput:\n```python\ntensor([[ 1,  0,  0,  0,  0],\n        [ 6,  7,  0,  0,  0],\n        [11, 12, 13,  0,  0],\n        [16, 17, 18, 19, 20],\n        [21, 22, 23, 24, 25]])\n```\n\nTest Case 4:\nInput:\n```python\nM = torch.tensor([[1, 2, 3, 4, 5, 6], [7, 8, 9, 10, 11, 12], [13, 14, 15, 16, 17, 18], [19, 20, 21, 22, 23, 24], [25, 26, 27, 28, 29, 30], [31, 32, 33, 34, 35, 36]])\n```\n\nOutput:\n```python\ntensor([[ 1,  0,  0,  0,  0,  0],\n        [ 7,  8,  0,  0,  0,  0],\n        [13, 14, 15,  0,  0,  0],\n        [19, 20, 21, 22, 23, 24],\n        [25, 26, 27, 28, 29, 30],\n        [31, 32, 33, 34, 35, 36]])\n```\n\nTest Case 5:\nInput:\n```python\nM = torch.tensor([[1, 2, 3, 4, 5, 6, 7], [8, 9, 10, 11, 12, 13, 14], [15, 16, 17, 18, 19, 20, 21], [22, 23, 24, 25, 26, 27, 28], [29, 30, 31, 32, 33, 34, 35], [36, 37, 38, 39, 40, 41, 42], [43, 44, 45, 46, 47, 48, 49]])", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\nimport functools\n\n\nclass TestSolution(unittest.TestCase):\n    def test_basic(self):\n        self.assertEqual(\n            functools.reduce(\n                lambda x, y: x * y,\n                algorithm(torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]])).shape,\n            ),\n            9,\n        )\n\n    def test_random(self):\n        for _ in range(10):\n            N = torch.randint(3, 10, (1,)).item()\n            M = torch.randint(-10, 10, (N, N))\n            self.assertEqual(\n                functools.reduce(\n                    lambda x, y: x * y,\n                    algorithm(M).shape,\n                ),\n                N * N,\n            )\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n", "\nTest your corrected solution with the provided test cases.\n\nTest Case 1:\nInput:\n```python\nM = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n```\n\nOutput:\n```python\ntensor([[1, 0, 0],\n        [4, 5, 0],\n        [7, 8, 9]])\n```\n\nTest Case 2:\nInput:\n```python\nM = torch.tensor([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]])\n```\n\nOutput:\n```python\ntensor([[ 1,  0,  0,  0],\n        [ 5,  6,  0,  0],\n        [ 9, 10, 11,  0],\n        [13, 14, 15, 16]])\n```\n\nTest Case 3:\nInput:\n```python\nM = torch.tensor([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]])\n```\n\nOutput:\n```python\ntensor([[ 1,  0,  0,  0,  0],\n        [ 6,  7,  0,  0,  0],\n        [11, 12, 13,  0,  0],\n        [16, 17, 18, 19, 20],\n        [21, 22, 23, 24, 25]])\n```\n\nTest Case 4:\nInput:\n```python\nM = torch.tensor([[1, 2, 3, 4, 5, 6], [7, 8, 9, 10, 11, 12], [13, 14, 15, 16, 17, 18], [19, 20, 21, 22, 23, 24], [25, 26, 27, 28, 29, 30], [31, 32, 33, 34, 35, 36]])\n```\n\nOutput:\n```python\ntensor([[ 1,  0,  0,  0,  0,  0],\n        [ 7,  8,  0,  0,  0,  0],\n        [13, 14, 15,  0,  0,  0],\n        [19, 20, 21, 22, 23, 24],\n        [25, 26, 27, 28, 29, 30],\n        [31, 32, 33, 34, 35, 36]])\n```\n\nTest Case 5:\nInput:\n```python\nM = torch.tensor([[1, 2, 3, 4, 5, 6, 7], [8, 9, 10, 11, 12, 13, 14], [15, 16, 17, 18, 19, 20, 21], [22, 23, 24, 25, 26, 27, 28], [29, 30, 31, 32, 33, 34, 35], [36, 37, 38, 39, 40, 41, 42], [43, 44, 45, 46, 47, 48, 49]])", "\nTest Your Solution:\nYou can test your solution like this:\n```python\nfrom helpers.python_test import test\n\n@test\ndef solution_works():\n    M = torch.randint(0, 10, (5, 5))\n    L = algorithm(M)\n    assert L.shape == (5, 5)\n    assert L.sum() == M.tril().sum()\n    assert (L == M.tril()).all()\n```\n'''\n\n# Solution\nimport torch\n\ndef algorithm(M: torch.Tensor) -> torch.Tensor:\n    '''\n    args:\n        M: torch.Tensor of shape (N, N)\n\n    return:\n        L: torch.Tensor of shape (N, N), which is the lower triangular part of M\n    '''\n    N = M.size(0)\n    L = torch.tensor([[M[i, j] if i <= j else 0 for j in range(N)] for i in range(N)])  \n    return L\n\n# Test your solution\nfrom helpers.python_test import test\n\n@test\ndef solution_works():\n    M = torch.randint(0, 10, (5, 5))\n    L = algorithm(M)\n    assert L.shape == (5, 5)\n    assert L.sum() == M.tril().sum()\n    assert (L == M.tril()).all()", "\nTest Your Solution:\n```python\nfrom utils.hog import algorithm\nfrom utils.tests import pyunit_fixture_plus, print_result\nimport torch\n\n@pyunit_fixture_plus\ndef fixture_plus():\n    M = torch.randint(0, 10, (5, 5))\n    return algorithm, (M, )\n\n_, (M, ) = fixture_plus()\nprint_result(algorithm(M))\n```\n\"\"\"\n\nimport torch\n\ndef algorithm(M: torch.Tensor) -> torch.Tensor:\n    '''\n    args:\n        M: torch.Tensor of shape (N, N)\n\n    return:\n        L: torch.Tensor of shape (N, N), which is the lower triangular part of M\n    '''\n    N = M.size(0)\n    L = torch.tensor([[M[i, j] if i <= j else 0 for j in range(N)] for i in range(N)])  \n    return L\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\nimport random\n\n\nclass TestSolution(unittest.TestCase):\n    def test_shape(self):\n        for _ in range(20):\n            N = random.randint(1, 100)\n            M = torch.rand(N, N)\n            L = algorithm(M)\n            self.assertEqual(L.shape, M.shape)\n\n    def test_values(self):\n        for _ in range(20):\n            N = random.randint(1, 100)\n            M = torch.rand(N, N)\n            L = algorithm(M)\n            for i in range(N):\n                for j in range(N):\n                    if i <= j:\n                        self.assertEqual(L[i, j], M[i, j])\n                    else:\n                        self.assertEqual(L[i, j], 0)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\nimport functools\n\n\ndef run(function_to_test, get_args, test_cases, name):\n    failed_test_cases = []\n\n    for index, (args, expected) in enumerate(test_cases):\n        try:\n            result = function_to_test(*args)\n            assert result.allclose(expected), (\n                f\"{name} test {index + 1} failed:\\nExpected\\n{expected}\\nGot\\n{result}\"\n            )\n        except AssertionError as e:\n            failed_test_cases.append(\n                f\"{name} test {index + 1} failed with input {args}:\\n{e}\"\n            )\n\n    if failed_test_cases:\n        msg = \"\\n\\n\".join(failed_test_cases)\n        raise AssertionError(f\"{len(failed_test_cases)} {name} tests failed:\\n{msg}\")\n\n\nclass TestAlgorithm(unittest.TestCase):\n    def test_algorithm(self):\n        def get_args(n):\n            return (torch.randint(-10, 10, (n, n)),)\n\n        run(\n            algorithm,\n            get_args,\n            [\n                (\n                    (3, 3),\n                    torch.tensor([[1, 0, 0], [2, 3, 0], [4, 5, 6]]),\n                ),\n                (\n                    (2, 2),\n                    torch.tensor([[1, 0], [2, 3]]),\n                ),\n                (\n                    (1, 1),\n                    torch.tensor([[1]]),\n                ),\n            ],\n            \"algorithm\",\n        )\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\nimport random\n\n\nclass TestSolution(unittest.TestCase):\n    def test_shape(self):\n        for _ in range(20):\n            N = random.randint(1, 100)\n            M = torch.rand(N, N)\n            L = algorithm(M)\n            self.assertEqual(L.shape, M.shape)\n\n    def test_correctness(self):\n        for _ in range(20):\n            N = random.randint(1, 100)\n            M = torch.rand(N, N)\n            L = algorithm(M)\n            for i in range(N):\n                for j in range(N):\n                    if i <= j:\n                        self.assertEqual(L[i, j], M[i, j])\n                    else:\n                        self.assertEqual(L[i, j], 0)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n", "\nTest Your Solution:\n```python\nfrom utils.hog import algorithm\nfrom utils.tests import pyunit_fixture_plus, get_test_filepath\nimport torch\n\n@pyunit_fixture_plus\ndef fixture_plus():\n    test_filepath = get_test_filepath(\n        path_to_file='.',\n        filename='algorithm-test-case.txt',\n        data_type='test',\n        )\n    with open(test_filepath) as input_file:\n        M = torch.tensor([[float(num) for num in line.split()] for line in input_file])\n    return M\n\ndef test_fixture_plus(fixture_plus):\n    assert fixture_plus.size(0) == fixture_plus.size(1)\n\ndef test_algorithm(fixture_plus):\n    L = algorithm(fixture_plus)\n    assert L.size(0) == fixture_plus.size(0)\n    assert L.size(1) == fixture_plus.size(1)\n    for i in range(fixture_plus.size(0)):\n        for j in range(fixture_plus.size(1)):\n            if i <= j:\n                assert L[i, j] == fixture_plus[i, j]\n            else:\n                assert L[i, j] == 0\n```\n\"\"\"\n\nimport torch\n\ndef algorithm(M: torch.Tensor) -> torch.Tensor:\n    '''\n    args:\n        M: torch.Tensor of shape (N, N)\n\n    return:\n        L: torch.Tensor of shape (N, N), which is the lower triangular part of M\n    '''\n    N = M.size(0)\n    L = torch.tensor([[M[i, j] if i <= j else 0 for j in range(N)] for i in range(N)])  \n    return L\n\n\nif __name__ == '__main__':\n    test_filepath = get_test_filepath(\n        path_to_file='.',\n        filename='algorithm-test-case.txt',\n        data_type='test',\n        )\n    with open(test_filepath) as input_file:\n        M = torch.tensor([[float(num) for num in line.split()] for line in input_file])\n    L = algorithm(M)\n    assert L.size(0) == M.size(0)\n    assert L.size(1) == M.size(1)\n    for i in range(M.size(0)):\n        for j in range(M.size(1)):\n            if i <= j:\n                assert L[i, j] == M[i, j]\n            else:\n                assert L[i, j] == 0\n", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\nimport functools\n\n\nclass TestSolution(unittest.TestCase):\n    def test(self):\n        torch.manual_seed(1)\n        M = torch.randint(-10, 10, (5, 5))\n        self.assertEqual(functools.reduce(lambda x, y: x * y, algorithm(M).shape),\n                         functools.reduce(lambda x, y: x * y, M.shape))\n        self.assertEqual(algorithm(M), torch.tril(M))\n\n\nif __name__ == '__main__':\n    unittest.main()\n", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\nimport random\n\n\nclass TestSolution(unittest.TestCase):\n    def test_shape(self):\n        for _ in range(20):\n            N = random.randint(1, 100)\n            M = torch.rand(N, N)\n            L = algorithm(M)\n            self.assertEqual(L.shape, (N, N))\n\n    def test_values(self):\n        for _ in range(20):\n            N = random.randint(1, 100)\n            M = torch.rand(N, N)\n            L = algorithm(M)\n            for i in range(N):\n                for j in range(N):\n                    if i <= j:\n                        self.assertEqual(L[i, j], M[i, j])\n                    else:\n                        self.assertEqual(L[i, j], 0)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\n\n\nclass TestSolution(unittest.TestCase):\n    def test(self):\n        M = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n        L = algorithm(M)\n        self.assertEqual(L.tolist(), [[1, 0, 0], [4, 5, 0], [7, 8, 9]])\n\n        M = torch.tensor([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]])\n        L = algorithm(M)\n        self.assertEqual(L.tolist(), [[1, 0, 0, 0], [5, 6, 0, 0], [9, 10, 11, 0], [13, 14, 15, 16]])\n\n        M = torch.tensor([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]])\n        L = algorithm(M)\n        self.assertEqual(L.tolist(), [[1, 0, 0, 0, 0], [6, 7, 0, 0, 0], [11, 12, 13, 0, 0], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]])\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\nimport functools\n\n\nclass TestSolution(unittest.TestCase):\n    def test(self):\n        torch.manual_seed(1)\n        M = torch.randint(-10, 10, (5, 5))\n        self.assertEqual(functools.reduce(lambda x, y: x * y, algorithm(M).shape),\n                         functools.reduce(lambda x, y: x * y, M.shape))\n        self.assertEqual(algorithm(M), torch.tril(M))\n\n\nif __name__ == '__main__':\n    unittest.main()\n", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\nimport functools\n\n\nclass TestSolution(unittest.TestCase):\n    def test(self):\n        torch.manual_seed(1)\n        M = torch.randint(-10, 10, (5, 5))\n        self.assertEqual(functools.reduce(lambda x, y: x * y, algorithm(M).shape),\n                         functools.reduce(lambda x, y: x * y, M.shape))\n        self.assertEqual(algorithm(M), torch.tril(M))\n\n        torch.manual_seed(2)\n        M = torch.randint(-10, 10, (10, 10))\n        self.assertEqual(functools.reduce(lambda x, y: x * y, algorithm(M).shape),\n                         functools.reduce(lambda x, y: x * y, M.shape))\n        self.assertEqual(algorithm(M), torch.tril(M))\n\n        torch.manual_seed(3)\n        M = torch.randint(-10, 10, (15, 15))\n        self.assertEqual(functools.reduce(lambda x, y: x * y, algorithm(M).shape),\n                         functools.reduce(lambda x, y: x * y, M.shape))\n        self.assertEqual(algorithm(M), torch.tril(M))\n\n        torch.manual_seed(4)\n        M = torch.randint(-10, 10, (20, 20))\n        self.assertEqual(functools.reduce(lambda x, y: x * y, algorithm(M).shape),\n                         functools.reduce(lambda x, y: x * y, M.shape))\n        self.assertEqual(algorithm(M), torch.tril(M))\n\n        torch.manual_seed(5)\n        M = torch.randint(-10, 10, (25, 25))\n        self.assertEqual(functools.reduce(lambda x, y: x * y, algorithm(M).shape),\n                         functools.reduce(lambda x, y: x * y, M.shape))\n        self.assertEqual(algorithm(M), torch.tril(M))\n\n        print('Passed')\n\n\nif __name__ == '__main__':\n    unittest.main()\n", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\nimport random\n\n\nclass TestSolution(unittest.TestCase):\n    def test_shape(self):\n        for _ in range(20):\n            N = random.randint(1, 100)\n            M = torch.rand(N, N)\n            L = algorithm(M)\n            self.assertEqual(L.shape, M.shape)\n\n    def test_values(self):\n        for _ in range(20):\n            N = random.randint(1, 100)\n            M = torch.rand(N, N)\n            L = algorithm(M)\n            for i in range(N):\n                for j in range(N):\n                    if i <= j:\n                        self.assertEqual(L[i, j], M[i, j])\n                    else:\n                        self.assertEqual(L[i, j], 0)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\nimport random\n\n\nclass TestSolution(unittest.TestCase):\n    def test_shape(self):\n        for _ in range(20):\n            N = random.randint(1, 100)\n            M = torch.rand(N, N)\n            L = algorithm(M)\n            self.assertEqual(L.shape, M.shape)\n\n    def test_correctness(self):\n        for _ in range(20):\n            N = random.randint(1, 100)\n            M = torch.rand(N, N)\n            L = algorithm(M)\n            for i in range(N):\n                for j in range(N):\n                    if i <= j:\n                        self.assertEqual(L[i, j], M[i, j])\n                    else:\n                        self.assertEqual(L[i, j], 0)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n", "\nTest your corrected solution with the provided test cases.\n\nTest Case 1:\nInput:\n```python\nM = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n```\n\nOutput:\n```python\ntensor([[1, 0, 0],\n        [4, 5, 0],\n        [7, 8, 9]])\n```\n\nTest Case 2:\nInput:\n```python\nM = torch.tensor([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]])\n```\n\nOutput:\n```python\ntensor([[ 1,  0,  0,  0],\n        [ 5,  6,  0,  0],\n        [ 9, 10, 11,  0],\n        [13, 14, 15, 16]])\n```\n\nTest Case 3:\nInput:\n```python\nM = torch.tensor([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]])\n```\n\nOutput:\n```python\ntensor([[ 1,  0,  0,  0,  0],\n        [ 6,  7,  0,  0,  0],\n        [11, 12, 13,  0,  0],\n        [16, 17, 18, 19, 20],\n        [21, 22, 23, 24, 25]])\n```\n\nTest Case 4:\nInput:\n```python\nM = torch.tensor([[1, 2, 3, 4, 5, 6], [7, 8, 9, 10, 11, 12], [13, 14, 15, 16, 17, 18], [19, 20, 21, 22, 23, 24], [25, 26, 27, 28, 29, 30], [31, 32, 33, 34, 35, 36]])\n```\n\nOutput:\n```python\ntensor([[ 1,  0,  0,  0,  0,  0],\n        [ 7,  8,  0,  0,  0,  0],\n        [13, 14, 15,  0,  0,  0],\n        [19, 20, 21, 22, 23, 24],\n        [25, 26, 27, 28, 29, 30],\n        [31, 32, 33, 34, 35, 36]])\n```\n\nTest Case 5:\nInput:\n```python\nM = torch.tensor([[1, 2, 3, 4, 5, 6, 7], [8, 9, 10, 11, 12, 13, 14], [15, 16, 17, 18, 19, 20, 21], [22, 23, 24, 25, 26, 27, 28], [29, 30, 31, 32, 33, 34, 35], [36, 37, 38, 39, 40, 41, 42], [43, 44, 45, 46, 47, 48, 49]])", "\nTest Your Solution:\n```python\nfrom utils.hog import algorithm\nfrom random import randint\nimport torch\n\nN = randint(1, 10)\nM = torch.randint(-10, 10, (N, N))\nL = algorithm(M)\n\nassert L.size() == (N, N)\nassert L.tril().equal(L)\n```\n\"\"\"\n\nimport torch\n\ndef algorithm(M: torch.Tensor) -> torch.Tensor:\n    '''\n    args:\n        M: torch.Tensor of shape (N, N)\n\n    return:\n        L: torch.Tensor of shape (N, N), which is the lower triangular part of M\n    '''\n    N = M.size(0)\n    L = torch.tensor([[M[i, j] if i <= j else 0 for j in range(N)] for i in range(N)])  \n    return L\n\n\nif __name__ == '__main__':\n    N = randint(1, 10)\n    M = torch.randint(-10, 10, (N, N))\n    L = algorithm(M)\n\n    assert L.size() == (N, N)\n    assert L.tril().equal(L)", "\nTest Your Solution:\nYou can test your solution like this:\n```python\nfrom helpers.python_test import test\n\n@test\ndef solution_works():\n    M = torch.randint(0, 10, (5, 5))\n    L = algorithm(M)\n    assert L.shape == (5, 5)\n    assert L.sum() == M.tril().sum()\n```\n'''\n\n# Solution\nimport torch\n\ndef algorithm(M: torch.Tensor) -> torch.Tensor:\n    '''\n    args:\n        M: torch.Tensor of shape (N, N)\n\n    return:\n        L: torch.Tensor of shape (N, N), which is the lower triangular part of M\n    '''\n    N = M.size(0)\n    L = torch.tensor([[M[i, j] if i <= j else 0 for j in range(N)] for i in range(N)])  \n    return L\n\n\n# Test your solution\nfrom helpers.python_test import test\n\n@test\ndef solution_works():\n    M = torch.randint(0, 10, (5, 5))\n    L = algorithm(M)\n    assert L.shape == (5, 5)\n    assert L.sum() == M.tril().sum()\n", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Udacityic\n# Author: Patrik Huss\n\nimport unittest\nimport torch\nfrom solve import algorithm\n\nclass TestSolution(unittest.TestCase):\n\n    def test_case_1(self):\n        M = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n        L = algorithm(M)\n        self.assertTrue(torch.equal(L, torch.tensor([[1, 0, 0], [4, 5, 0], [7, 8, 9]])))\n\n    def test_case_2(self):\n        M = torch.tensor([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]])\n        L = algorithm(M)\n        self.assertTrue(torch.equal(L, torch.tensor([[1, 0, 0, 0], [5, 6, 0, 0], [9, 10, 11, 0], [13, 14, 15, 16]])))\n\nif __name__ == \"__main__\":\n    unittest.main()", "\nTest Your Solution:\nYou can test your solution like this:\n```python\nfrom helpers.python_test import test\n\n@pytest.mark.parametrize(\"M,expected\", [\n    (torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]]), torch.tensor([[1, 0, 0], [4, 5, 0], [7, 8, 9]])),\n    (torch.tensor([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]), torch.tensor([[1, 0, 0, 0], [5, 6, 0, 0], [9, 10, 11, 0], [13, 14, 15, 16]])),\n    (torch.tensor([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]]), torch.tensor([[1, 0, 0, 0, 0], [6, 7, 0, 0, 0], [11, 12, 13, 0, 0], [16, 17, 18, 19, 0], [21, 22, 23, 24, 25]])),\n])\ndef test_algorithm(M, expected):\n    result = algorithm(M)\n    assert torch.all(torch.eq(result, expected))\n```\n\"\"\"\n\nimport torch\n\ndef algorithm(M: torch.Tensor) -> torch.Tensor:\n    '''\n    args:\n        M: torch.Tensor of shape (N, N)\n\n    return:\n        L: torch.Tensor of shape (N, N), which is the lower triangular part of M\n    '''\n    N = M.size(0)\n    L = torch.tensor([[M[i, j] if i <= j else 0 for j in range(N)] for i in range(N)])  \n    return L\n\n\nif __name__ == \"__main__\":\n    test()\n", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\nimport functools\n\n\ndef run(function_to_test, get_args, test_cases):\n    \"\"\"Runs a set of tests cases for a given function\"\"\"\n    for test_case in test_cases:\n        input_arguments = test_case[\"input\"]\n        desired_result = test_case[\"output\"]\n        print(\"\\nRunning test for arguments\", input_arguments)\n        actual = function_to_test(*input_arguments)\n        assert desired_result == actual, f\"Expected result: {desired_result}; Actual result: {actual}\"\n        print(\"Test passed!\")\n\n\ndef get_lower_triangular(M):\n    \"\"\"\n    args:\n        M: torch.Tensor of shape (N, N)\n\n    return:\n        L: torch.Tensor of shape (N, N), which is the lower triangular part of M\n    \"\"\"\n    N = M.size(0)\n    L = torch.tensor([[M[i, j] if i <= j else 0 for j in range(N)] for i in range(N)])\n    return L\n\n\nclass TestAlgorithm(unittest.TestCase):\n    def test_algorithm(self):\n        test_cases = [\n            {\n                \"input\": (torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),),\n                \"output\": torch.tensor([[1, 0, 0], [4, 5, 0], [7, 8, 9]])\n            },\n            {\n                \"input\": (torch.tensor([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]),),\n                \"output\": torch.tensor([[1, 0, 0, 0], [5, 6, 0, 0], [9, 10, 11, 0], [13, 14, 15, 16]])\n            },\n            {\n                \"input\": (torch.tensor([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]]),),\n                \"output\": torch.tensor([[1, 0, 0, 0, 0], [6, 7, 0, 0, 0], [11, 12, 13, 0, 0], [16, 17, 18, 19, 0], [21, 22, 23, 24, 25]])\n            }\n        ]\n        run(get_lower_triangular, get_args, test_cases)\n\n\nif __name__ == '__main__':\n    unittest.main()\n", "\nTest Your Solution:\n```python\nfrom utils.hog import algorithm\nfrom random import randint\nimport torch\n\nN = randint(1, 10)\nM = torch.randint(0, 10, (N, N))\nL = algorithm(M)\n\nassert L.shape == (N, N)\nassert L.sum() == M.tril().sum()\nassert L.tril() == M.tril()\n```\n\"\"\"\n\nimport torch\n\ndef algorithm(M: torch.Tensor) -> torch.Tensor:\n    '''\n    args:\n        M: torch.Tensor of shape (N, N)\n\n    return:\n        L: torch.Tensor of shape (N, N), which is the lower triangular part of M\n    '''\n    N = M.size(0)\n    L = torch.tensor([[M[i, j] if i <= j else 0 for j in range(N)] for i in range(N)])  \n    return L\n\n\nif __name__ == '__main__':\n    N = randint(1, 10)\n    M = torch.randint(0, 10, (N, N))\n    L = algorithm(M)\n\n    assert L.shape == (N, N)\n    assert L.sum() == M.tril().sum()\n    assert L.tril() == M.tril()\n", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\nimport random\n\n\nclass TestSolution(unittest.TestCase):\n    def test_shape(self):\n        for _ in range(20):\n            N = random.randint(1, 100)\n            M = torch.rand(N, N)\n            L = algorithm(M)\n            self.assertEqual(L.shape, M.shape)\n\n    def test_values(self):\n        for _ in range(20):\n            N = random.randint(1, 100)\n            M = torch.rand(N, N)\n            L = algorithm(M)\n            for i in range(N):\n                for j in range(N):\n                    if i <= j:\n                        self.assertEqual(L[i, j], M[i, j])\n                    else:\n                        self.assertEqual(L[i, j], 0)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n", "\nTest Your Solution:\nYou can test your solution like this:\n```python\nfrom helpers.python_test import test\n\n@pytest.mark.parametrize(\"M,expected\", [\n    (torch.rand(3, 3), torch.tril(torch.rand(3, 3))),\n    (torch.rand(4, 4), torch.tril(torch.rand(4, 4))),\n    (torch.rand(5, 5), torch.tril(torch.rand(5, 5))),\n])\ndef test_algorithm(M: torch.Tensor, expected: torch.Tensor):\n    result = algorithm(M)\n    assert torch.all(torch.eq(result, expected))\n```\n\"\"\"\n\nimport torch\n\ndef algorithm(M: torch.Tensor) -> torch.Tensor:\n    '''\n    args:\n        M: torch.Tensor of shape (N, N)\n\n    return:\n        L: torch.Tensor of shape (N, N), which is the lower triangular part of M\n    '''\n    N = M.size(0)\n    L = torch.tensor([[M[i, j] if i <= j else 0 for j in range(N)] for i in range(N)])  \n    return L\n\nif __name__ == \"__main__\":\n    test()\n", "\nTest Your Solution:\nYou can test your solution like this:\n```python\nfrom helpers.python_test import test\n\n@pytest.mark.parametrize(\"M,expected\", [\n    (torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]]), torch.tensor([[1, 0, 0], [4, 5, 0], [7, 8, 9]])),\n    (torch.tensor([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]), torch.tensor([[1, 0, 0, 0], [5, 6, 0, 0], [9, 10, 11, 0], [13, 14, 15, 16]])),\n    (torch.tensor([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]]), torch.tensor([[1, 0, 0, 0, 0], [6, 7, 0, 0, 0], [11, 12, 13, 0, 0], [16, 17, 18, 19, 0], [21, 22, 23, 24, 25]])),\n])\ndef test_algorithm(M, expected):\n    result = algorithm(M)\n    assert torch.all(torch.eq(result, expected))\n```\n\"\"\"\n\nimport torch\n\ndef algorithm(M: torch.Tensor) -> torch.Tensor:\n    '''\n    args:\n        M: torch.Tensor of shape (N, N)\n\n    return:\n        L: torch.Tensor of shape (N, N), which is the lower triangular part of M\n    '''\n    N = M.size(0)\n    L = torch.tensor([[M[i, j] if i <= j else 0 for j in range(N)] for i in range(N)])  \n    return L\n\n\nif __name__ == '__main__':\n    from helpers.python_test import test\n    from helpers.torch_test import test_module\n\n    test_cases = [\n        (torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]]), torch.tensor([[1, 0, 0], [4, 5, 0], [7, 8, 9]])),\n        (torch.tensor([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]), torch.tensor([[1, 0, 0, 0], [5, 6, 0, 0], [9, 10, 11, 0], [13, 14, 15, 16]])),\n        (torch.tensor([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]]), torch.tensor([[1, 0, 0, 0, 0], [6, 7, 0, 0, 0], [11, 12, 13, 0, 0], [", "\nTest Your Solution:\n```python\nfrom utils.hog import algorithm\nfrom utils.tests import pyunit_fixture_plus, print_result\nimport torch\n\n@pyunit_fixture_plus\ndef fixture_plus():\n    M = torch.randint(0, 10, (5, 5))\n    return algorithm, (M, )\n\ndef test_correct(fixture_plus):\n    func, args = fixture_plus\n    result = func(*args)\n    correct = torch.tril(args[0])\n    assert torch.allclose(result, correct)\n    print_result(result, correct)\n```\n\"\"\"\n\nimport torch\n\ndef algorithm(M: torch.Tensor) -> torch.Tensor:\n    '''\n    args:\n        M: torch.Tensor of shape (N, N)\n\n    return:\n        L: torch.Tensor of shape (N, N), which is the lower triangular part of M\n    '''\n    N = M.size(0)\n    L = torch.tensor([[M[i, j] if i <= j else 0 for j in range(N)] for i in range(N)])  \n    return L\n\n\nif __name__ == '__main__':\n    from utils.tests import pyunit_fixture_plus, print_result\n    import torch\n\n    @pyunit_fixture_plus\n    def fixture_plus():\n        M = torch.randint(0, 10, (5, 5))\n        return algorithm, (M, )\n\n    def test_correct(fixture_plus):\n        func, args = fixture_plus\n        result = func(*args)\n        correct = torch.tril(args[0])\n        assert torch.allclose(result, correct)\n        print_result(result, correct)\n", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Udacity\n# Author: Alexis M. Thornton\n\nimport torch\n\ndef algorithm(M: torch.Tensor) -> torch.Tensor:\n    '''\n    args:\n        M: torch.Tensor of shape (N, N)\n\n    return:\n        L: torch.Tensor of shape (N, N), which is the lower triangular part of M\n    '''\n    N = M.size(0)\n    L = torch.tensor([[M[i, j] if i <= j else 0 for j in range(N)] for i in range(N)])  \n    return L\n\n\n# test cases\ntest1 = torch.rand(3, 3)\nexpected = algorithm(test1)\nprint(expected)\n\ntest2 = torch.rand(4, 4)\nexpected = algorithm(test2)\nprint(expected)\n\ntest3 = torch.rand(5, 5)\nexpected = algorithm(test3)\nprint(expected)\n", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\nimport random\n\n\nclass TestSolution(unittest.TestCase):\n    def test_shape(self):\n        for _ in range(20):\n            N = random.randint(1, 100)\n            M = torch.rand(N, N)\n            L = algorithm(M)\n            self.assertEqual(L.shape, (N, N))\n\n    def test_values(self):\n        for _ in range(20):\n            N = random.randint(1, 100)\n            M = torch.rand(N, N)\n            L = algorithm(M)\n            for i in range(N):\n                for j in range(N):\n                    if i <= j:\n                        self.assertEqual(L[i, j], M[i, j])\n                    else:\n                        self.assertEqual(L[i, j], 0)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Udacityic\n# Author: Patricio Trevino\n\nimport unittest\nimport torch\n\n\ndef algorithm(M: torch.Tensor) -> torch.Tensor:\n    '''\n    args:\n        M: torch.Tensor of shape (N, N)\n\n    return:\n        L: torch.Tensor of shape (N, N), which is the lower triangular part of M\n    '''\n    N = M.size(0)\n    L = torch.tensor([[M[i, j] if i <= j else 0 for j in range(N)] for i in range(N)])\n    return L\n\n\nclass TestAlgorithm(unittest.TestCase):\n\n    def test_algorithm(self):\n        M = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n        L = algorithm(M)\n        self.assertTrue(torch.equal(L, torch.tensor([[1, 0, 0], [4, 5, 0], [7, 8, 9]])))\n\n        M = torch.tensor([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]])\n        L = algorithm(M)\n        self.assertTrue(torch.equal(L, torch.tensor([[1, 0, 0, 0], [5, 6, 0, 0], [9, 10, 11, 0], [13, 14, 15, 16]])))\n\n        M = torch.tensor([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]])\n        L = algorithm(M)\n        self.assertTrue(torch.equal(L, torch.tensor([[1, 0, 0, 0, 0], [6, 7, 0, 0, 0], [11, 12, 13, 0, 0], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]])))\n\n\nif __name__ == '__main__':\n    unittest.main()\n", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\nimport random\n\n\nclass TestSolution(unittest.TestCase):\n    def test_shape(self):\n        for _ in range(20):\n            N = random.randint(1, 100)\n            M = torch.rand(N, N)\n            L = algorithm(M)\n            self.assertEqual(L.shape, M.shape)\n\n    def test_values(self):\n        for _ in range(20):\n            N = random.randint(1, 100)\n            M = torch.rand(N, N)\n            L = algorithm(M)\n            for i in range(N):\n                for j in range(N):\n                    if i <= j:\n                        self.assertEqual(L[i, j], M[i, j])\n                    else:\n                        self.assertEqual(L[i, j], 0)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n", "\nTest your corrected solution with the provided test cases.\n\nTest Case 1:\n\nInput:\n```python\nM = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n```\n\nOutput:\n```python\ntensor([[1, 0, 0],\n        [4, 5, 0],\n        [7, 8, 9]])\n```\n\nTest Case 2:\n\nInput:\n```python\nM = torch.tensor([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]])\n```\n\nOutput:\n```python\ntensor([[ 1,  0,  0,  0],\n        [ 5,  6,  0,  0],\n        [ 9, 10, 11,  0],\n        [13, 14, 15, 16]])\n```\n\nTest Case 3:\n\nInput:\n```python\nM = torch.tensor([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]])\n```\n\nOutput:\n```python\ntensor([[ 1,  0,  0,  0,  0],\n        [ 6,  7,  0,  0,  0],\n        [11, 12, 13,  0,  0],\n        [16, 17, 18, 19, 20],\n        [21, 22, 23, 24, 25]])\n```\n\nTest Case 4:\n\nInput:\n```python\nM = torch.tensor([[1, 2, 3, 4, 5, 6], [7, 8, 9, 10, 11, 12], [13, 14, 15, 16, 17, 18], [19, 20, 21, 22, 23, 24], [25, 26, 27, 28, 29, 30], [31, 32, 33, 34, 35, 36]])\n```\n\nOutput:\n```python\ntensor([[ 1,  0,  0,  0,  0,  0],\n        [ 7,  8,  0,  0,  0,  0],\n        [13, 14, 15,  0,  0,  0],\n        [19, 20, 21, 22, 23,  0],\n        [25, 26, 27, 28, 29, 30],\n        [31, 32, 33, 34, 35, 36]])\n```\n\nTest Case 5:\n\nInput:\n```python\nM = torch.tensor([[1, 2, 3, 4, 5, 6, 7], [8, 9, 10, 11, 12, 13, 14], [15, 16, 17, 18, 19, 20, 21], [22, 23, 24, 25, 26, 27, 28], [29, 30, 31, 32, 33, 34, 35], [36, 37, 38, 39, 40, 41, 42], [43, 44, 45, 46, 47, 48,", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\n\n\nclass TestSolution(unittest.TestCase):\n    def test(self):\n        M = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n        L = algorithm(M)\n        self.assertEqual(L.tolist(), [[1, 0, 0], [4, 5, 0], [7, 8, 9]])\n\n        M = torch.tensor([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]])\n        L = algorithm(M)\n        self.assertEqual(L.tolist(), [[1, 0, 0, 0], [5, 6, 0, 0], [9, 10, 11, 0], [13, 14, 15, 16]])\n\n        M = torch.tensor([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]])\n        L = algorithm(M)\n        self.assertEqual(L.tolist(), [[1, 0, 0, 0, 0], [6, 7, 0, 0, 0], [11, 12, 13, 0, 0], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]])\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\nimport functools\n\n\nclass TestSolution(unittest.TestCase):\n    def test(self):\n        torch.manual_seed(1)\n        M = torch.randint(0, 10, (5, 5))\n        self.assertEqual(functools.reduce(torch.add, algorithm(M)), M)\n\n\nif __name__ == '__main__':\n    unittest.main()\n", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\nimport functools\n\n\ndef run(function_to_test, get_args, test_cases, name):\n    failed_test_cases = []\n\n    for index, (args, expected) in enumerate(test_cases):\n        try:\n            result = function_to_test(*args)\n            assert result.allclose(expected), (\n                f\"{name} test {index + 1} failed:\\nExpected\\n{expected}\\nGot\\n{result}\"\n            )\n        except AssertionError as e:\n            failed_test_cases.append(\n                f\"{name} test {index + 1} failed with input {args}:\\n{e}\"\n            )\n\n    if failed_test_cases:\n        msg = \"\\n\\n\".join(failed_test_cases)\n        raise AssertionError(f\"{len(failed_test_cases)} {name} tests failed:\\n{msg}\")\n\n\ndef get_lower_triangular_part_test_cases():\n    # test_cases: [(test_input, expected_result), ...]\n    test_cases = [\n        (([[1, 2, 3], [4, 5, 6], [7, 8, 9]],), [[1, 0, 0], [4, 5, 0], [7, 8, 9]]),\n        (([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]],), [[1, 0, 0], [4, 5, 0], [7, 8, 9], [10, 11, 12]]),\n        (([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15]],), [[1, 0, 0], [4, 5, 0], [7, 8, 9], [10, 11, 12], [13, 14, 15]]),\n        (([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18]],), [[1, 0, 0], [4, 5, 0], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18]]),\n        (([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18], [19, 20, 21]],), [[1, 0, 0], [4, 5, 0], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18], [19, 20, 21]]),\n        (([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18], [19, 20, 21], [22, 23, 24]],), [[1, 0, 0], [4, 5, 0], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18], [19, ", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\nimport functools\n\n\nclass TestSolution(unittest.TestCase):\n    def test(self):\n        torch.manual_seed(1)\n        M = torch.randint(-10, 10, (5, 5))\n        self.assertEqual(functools.reduce(lambda x, y: x * y, algorithm(M).shape),\n                         functools.reduce(lambda x, y: x * y, M.shape))\n        self.assertEqual(algorithm(M), torch.tril(M))\n\n        torch.manual_seed(2)\n        M = torch.randint(-10, 10, (10, 10))\n        self.assertEqual(functools.reduce(lambda x, y: x * y, algorithm(M).shape),\n                         functools.reduce(lambda x, y: x * y, M.shape))\n        self.assertEqual(algorithm(M), torch.tril(M))\n\n        torch.manual_seed(3)\n        M = torch.randint(-10, 10, (15, 15))\n        self.assertEqual(functools.reduce(lambda x, y: x * y, algorithm(M).shape),\n                         functools.reduce(lambda x, y: x * y, M.shape))\n        self.assertEqual(algorithm(M), torch.tril(M))\n\n        print('All tests passed!')\n\n\nif __name__ == '__main__':\n    unittest.main()\n", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\nimport random\n\n\nclass TestSolution(unittest.TestCase):\n    def test_shape(self):\n        for _ in range(20):\n            N = random.randint(1, 100)\n            M = torch.rand(N, N)\n            L = algorithm(M)\n            self.assertEqual(L.shape, M.shape)\n\n    def test_values(self):\n        for _ in range(20):\n            N = random.randint(1, 100)\n            M = torch.rand(N, N)\n            L = algorithm(M)\n            for i in range(N):\n                for j in range(N):\n                    if i <= j:\n                        self.assertEqual(L[i, j], M[i, j])\n                    else:\n                        self.assertEqual(L[i, j], 0)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Udacity\n# Author: Alexis M. Thornton\n\nimport torch\n\ndef algorithm(M: torch.Tensor) -> torch.Tensor:\n    '''\n    args:\n        M: torch.Tensor of shape (N, N)\n\n    return:\n        L: torch.Tensor of shape (N, N), which is the lower triangular part of M\n    '''\n    N = M.size(0)\n    L = torch.tensor([[M[i, j] if i <= j else 0 for j in range(N)] for i in range(N)])  \n    return L\n\n\n# test case\nN = 5\nM = torch.rand(N, N)\nL = algorithm(M)\n\nassert L.shape == (N, N), \"Wrong shape of L\"\nassert L.tril().sum() == L.sum(), \"Not all elements are lower triangular\"\n", "\nTest your corrected solution with the provided test cases.\n'''\n\n# Use this to test your solution. Don't edit any of the code below this line!\n\nimport unittest\nimport random\n\n\nclass TestSolution(unittest.TestCase):\n    def test_shape(self):\n        for _ in range(20):\n            N = random.randint(1, 100)\n            M = torch.rand(N, N)\n            L = algorithm(M)\n            self.assertEqual(L.shape, M.shape)\n\n    def test_values(self):\n        for _ in range(20):\n            N = random.randint(1, 100)\n            M = torch.rand(N, N)\n            L = algorithm(M)\n            for i in range(N):\n                for j in range(N):\n                    if i <= j:\n                        self.assertEqual(L[i, j], M[i, j])\n                    else:\n                        self.assertEqual(L[i, j], 0)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n"]